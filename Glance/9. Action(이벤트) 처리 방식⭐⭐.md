> [!TIP] 🗣️ 핵심내용
사용자 인터랙션을 처리하는 방법: actionRunCallback, actionStartActivity, actionStartService 등을 다룹니다.
>

## 1. Action 개요

Glance 위젯에서 사용자의 클릭, 탭 등의 인터랙션을 처리하는 방법입니다. RemoteViews 기반이므로 PendingIntent를 통해 동작합니다.

```
👆 사용자 클릭
   │
   ▼
🎯 clickable(onClick = action...)
   │
   ▼
📡 PendingIntent 실행
   │
   ├─→ 🔄 `actionRunCallback` (위젯 내부 로직)
   ├─→ 📱 `actionStartActivity` (액티비티 실행)
   ├─→ ⚙️ `actionStartService` (서비스 실행, Deprecated)
   └─→ 📻 `actionSendBroadcast` (브로드캐스트 전송)
```

---

## 2. Action 유형

### 2.1 `actionRunCallback`
- **가장 많이 사용**하는 방식
- 위젯 내부에서 **상태 변경 + UI 갱신**을 처리
- `ActionCallback` 인터페이스를 구현한 클래스 필요

```kotlin
class CounterWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val prefs = currentState<Preferences>()
            val count = prefs[intPreferencesKey("count")] ?: 0

            Column(
                modifier = GlanceModifier.fillMaxSize(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text("Count: $count")
                Button(
                    text = "증가",
                    onClick = actionRunCallback<IncrementAction>()
                )
            }
        }
    }
}

// ActionCallback 구현
class IncrementAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 상태 업데이트
        updateAppWidgetState(context, glanceId) { prefs ->
            val current = prefs[intPreferencesKey("count")] ?: 0
            prefs[intPreferencesKey("count")] = current + 1
        }

        // 2. UI 갱신 (필수!)
        CounterWidget().update(context, glanceId)
    }
}
```

> [!NOTE] 💬 발표 설명
> "**ActionCallback의 실행 흐름**을 이해하는 게 중요합니다.
>
> 1. **사용자 클릭**: 사용자가 Button을 탭하면 `onClick = actionRunCallback<IncrementAction>()`이 트리거됩니다.
>
> 2. **시스템 호출**: Glance 시스템이 IncrementAction 클래스를 찾아서 인스턴스를 만들고 `onAction()` 메서드를 호출합니다. 이 과정에서 **리플렉션**이 사용되기 때문에 ProGuard 규칙이 필요한 거죠.
>
> 3. **상태 업데이트**: `updateAppWidgetState()`로 DataStore에 새로운 값을 저장합니다. 하지만 이것만으로는 화면이 안 바뀝니다!
>
> 4. **UI 갱신**: `CounterWidget().update()`를 호출해야 `provideGlance()`가 다시 실행되면서 화면이 업데이트됩니다. **이 단계를 빼먹으면 클릭해도 아무 일도 안 일어나는 것처럼 보입니다.**
>
> **핵심**: ActionCallback은 단순히 로직만 실행하는 게 아니라 '상태 변경 → UI 갱신' 두 단계를 모두 책임집니다."

**[스크린샷 추천]** 버튼 클릭 시 카운터가 증가하는 위젯 화면

---

### 2.2 `actionStartActivity`
- 특정 **Activity를 실행**할 때 사용
- 위젯에서 앱의 메인 화면이나 특정 기능으로 이동

```kotlin
Button(
    text = "앱 열기",
    onClick = actionStartActivity<MainActivity>()
)

// 파라미터 전달
Button(
    text = "상세보기",
    onClick = actionStartActivity(
        Intent(context, DetailActivity::class.java).apply {
            putExtra("item_id", itemId)
        }
    )
)

// ComponentName으로 지정
Button(
    text = "설정 열기",
    onClick = actionStartActivity(
        ComponentName(context, SettingsActivity::class.java)
    )
)
```

---

### 2.3 `actionStartService` (Deprecated)
- Android 8.0(API 26)부터 백그라운드 서비스 제한으로 **사용 권장하지 않음**
- 대신 **WorkManager** 또는 **`actionRunCallback`**에서 작업 처리

```kotlin
// ❌ 권장하지 않음
onClick = actionStartService<MyService>()

// ✅ 대안: actionRunCallback에서 WorkManager 사용
class RefreshAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // WorkManager로 백그라운드 작업 예약
        val workRequest = OneTimeWorkRequestBuilder<RefreshWorker>().build()
        WorkManager.getInstance(context).enqueue(workRequest)

        // UI 즉시 갱신
        MyWidget().update(context, glanceId)
    }
}
```

---

### 2.4 `actionSendBroadcast`
- 특정 **BroadcastReceiver를 호출**할 때 사용
- 앱의 특정 리시버로 브로드캐스트를 전송하거나, 시스템 브로드캐스트를 보낼 때 활용
- 알람 설정, 토글 동작 등에 유용

```kotlin
// 1. BroadcastReceiver 정의
class WidgetBroadcastReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            "com.example.ACTION_TOGGLE" -> {
                val glanceIdString = intent.getStringExtra("glance_id") ?: return
                val glanceId = GlanceId(glanceIdString)

                // 상태 토글
                GlobalScope.launch {
                    updateAppWidgetState(context, glanceId) { prefs ->
                        val current = prefs[booleanPreferencesKey("enabled")] ?: false
                        prefs[booleanPreferencesKey("enabled")] = !current
                    }
                    MyWidget().update(context, glanceId)
                }
            }
        }
    }
}

// 2. AndroidManifest.xml에 등록
<receiver android:name=".WidgetBroadcastReceiver"
    android:exported="false">
    <intent-filter>
        <action android:name="com.example.ACTION_TOGGLE" />
    </intent-filter>
</receiver>

// 3. 위젯에서 브로드캐스트 액션 사용
Button(
    text = "토글",
    onClick = actionSendBroadcast(
        Intent("com.example.ACTION_TOGGLE").apply {
            setPackage(context.packageName)
            putExtra("glance_id", glanceId.toString())
        }
    )
)

// 또는 ComponentName으로 명시적 호출
Button(
    text = "명시적 브로드캐스트",
    onClick = actionSendBroadcast(
        ComponentName(context, WidgetBroadcastReceiver::class.java),
        Intent("com.example.ACTION_CUSTOM").apply {
            putExtra("data", "value")
        }
    )
)
```

> [!NOTE] 💬 actionSendBroadcast 사용 시나리오
> **actionRunCallback과 actionSendBroadcast의 차이**:
>
> - **actionRunCallback**: 위젯 전용 로직, 상태 관리와 UI 업데이트가 주 목적
> - **actionSendBroadcast**: 앱의 다른 컴포넌트와 통신, 시스템 이벤트 전달
>
> **사용 예시**:
> - 알람 앱의 위젯에서 알람 on/off 토글 → 알람 매니저에 브로드캐스트
> - 미디어 위젯에서 재생/일시정지 → 미디어 서비스에 브로드캐스트
> - 위젯에서 앱의 특정 기능 트리거 (예: 동기화, 새로고침)

**[스크린샷 추천]** 토글 버튼이 있는 위젯 (브로드캐스트로 상태 변경)

---

### 2.5 `action` (커스텀 Action)

#### 2.5.1 커스텀 Action이 존재하는 이유

Glance는 이미 `actionRunCallback`, `actionStartActivity`, `actionSendBroadcast` 같은 편리한 래퍼 API를 제공합니다. 그런데 왜 원시적인 `action()` API를 열어놓았을까요?

> [!NOTE] 설계 철학: "Escape Hatch" (탈출구)
> Jetpack Compose와 Glance는 **"고수준 API가 충분하지 않을 때 저수준으로 직접 제어할 수 있는 탈출구"**를 제공하는 철학을 따릅니다.
>
> **래퍼 API의 한계**:
> - `actionRunCallback`: 앱 내부 위젯 로직에만 적합
> - `actionStartActivity`: 앱 내 Activity 실행에만 적합
> - `actionSendBroadcast`: 브로드캐스트만 지원
>
> **커버되지 않는 사용 사례**:
> 1. **시스템 인텐트**: 전화 걸기, 알람 설정, 브라우저 열기, 시스템 설정 등
> 2. **써드파티 앱 통합**: 다른 앱의 딥링크, 공유 인텐트
> 3. **PendingIntent 세밀 제어**: 플래그(FLAG_IMMUTABLE, FLAG_UPDATE_CURRENT 등) 커스터마이징
> 4. **레거시 마이그레이션**: 기존 AppWidget 코드의 PendingIntent 로직 재사용
> 5. **미래 확장성**: 아직 래퍼가 없는 새로운 유형의 액션
>
> **핵심**: 래퍼 API는 **80%의 일반적인 사용 사례**를 커버하고, `action()`은 **나머지 20%의 특수 케이스**를 위한 것입니다.

#### 2.5.2 기본 사용법

```kotlin
Button(
    text = "커스텀 액션",
    onClick = action(
        Intent(context, MyReceiver::class.java).apply {
            action = "com.example.CUSTOM_ACTION"
            putExtra("data", "value")
        }
    )
)
```

#### 2.5.3 실전 사용 사례

##### 사례 1: 시스템 전화 걸기

```kotlin
// 래퍼 API로는 불가능 - 시스템 다이얼러 실행
Button(
    text = "긴급 전화",
    onClick = action(
        Intent(Intent.ACTION_DIAL).apply {
            data = Uri.parse("tel:119")
        }
    )
)
```

##### 사례 2: 브라우저 URL 열기

```kotlin
// 래퍼 API로는 불가능 - 시스템 브라우저 실행
Button(
    text = "홈페이지 열기",
    onClick = action(
        Intent(Intent.ACTION_VIEW).apply {
            data = Uri.parse("https://developer.android.com")
        }
    )
)
```

##### 사례 3: 시스템 알람 설정

```kotlin
// 시스템 알람 앱 열기 (특정 시간으로 알람 설정)
Button(
    text = "알람 설정",
    onClick = action(
        Intent(AlarmClock.ACTION_SET_ALARM).apply {
            putExtra(AlarmClock.EXTRA_HOUR, 7)
            putExtra(AlarmClock.EXTRA_MINUTES, 30)
            putExtra(AlarmClock.EXTRA_MESSAGE, "기상 알람")
        }
    )
)

// 필요 권한: AndroidManifest.xml
// <uses-permission android:name="com.android.alarm.permission.SET_ALARM" />
```

##### 사례 4: 구글 맵 특정 위치 열기

```kotlin
// 써드파티 앱(구글 맵) 딥링크
Button(
    text = "위치 보기",
    onClick = action(
        Intent(Intent.ACTION_VIEW).apply {
            data = Uri.parse("geo:37.5665,126.9780?q=서울특별시청")
        }
    )
)
```

##### 사례 5: 이메일 작성 (공유 인텐트)

```kotlin
Button(
    text = "피드백 보내기",
    onClick = action(
        Intent(Intent.ACTION_SENDTO).apply {
            data = Uri.parse("mailto:")
            putExtra(Intent.EXTRA_EMAIL, arrayOf("support@example.com"))
            putExtra(Intent.EXTRA_SUBJECT, "위젯 피드백")
            putExtra(Intent.EXTRA_TEXT, "내용을 입력하세요")
        }
    )
)
```

##### 사례 6: PendingIntent 플래그 커스터마이징

```kotlin
// 특수한 PendingIntent 플래그가 필요한 경우
// (예: 기존 PendingIntent를 취소하고 새로 생성)
val customIntent = Intent(context, MyActivity::class.java)
val pendingIntent = PendingIntent.getActivity(
    context,
    requestCode,
    customIntent,
    PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_CANCEL_CURRENT // 세밀한 제어
)

Button(
    text = "특수 액션",
    onClick = action(pendingIntent)
)
```

##### 사례 7: 시스템 설정 화면 열기

```kotlin
// Wi-Fi 설정 화면 열기
Button(
    text = "Wi-Fi 설정",
    onClick = action(
        Intent(Settings.ACTION_WIFI_SETTINGS)
    )
)

// 앱 상세 설정 화면 열기 (권한 관리)
Button(
    text = "권한 설정",
    onClick = action(
        Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
            data = Uri.parse("package:${context.packageName}")
        }
    )
)
```

##### 사례 8: 다른 앱 실행 (Package Name)

```kotlin
// 특정 앱이 설치되어 있을 때 실행
Button(
    text = "카카오톡 열기",
    onClick = action(
        context.packageManager.getLaunchIntentForPackage("com.kakao.talk")
            ?: Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=com.kakao.talk"))
    )
)
```

> [!NOTE] 💬 발표 설명
> "**action()을 사용하는 8가지 실전 시나리오**를 정리했습니다.
>
> **1-2. 시스템 앱 실행**: 전화, 브라우저는 `Intent.ACTION_DIAL`, `Intent.ACTION_VIEW` 같은 시스템 인텐트로만 가능합니다. `actionStartActivity`로는 앱 내 Activity만 실행할 수 있죠.
>
> **3. 시스템 알람**: `AlarmClock.ACTION_SET_ALARM`은 시스템 알람 앱에 특정 시간 알람을 설정하는 특수 액션입니다. 래퍼 API로는 불가능합니다.
>
> **4-5. 써드파티 통합**: 구글 맵 딥링크(`geo:`)나 이메일 작성(`mailto:`)은 다른 앱과의 통합이므로 커스텀 인텐트가 필요합니다.
>
> **6. PendingIntent 플래그 제어**: `FLAG_CANCEL_CURRENT`, `FLAG_UPDATE_CURRENT`, `FLAG_ONE_SHOT` 등 PendingIntent의 세밀한 동작을 제어해야 할 때 직접 생성합니다.
>
> **7. 시스템 설정**: Wi-Fi 설정이나 앱 권한 설정 화면은 시스템 Settings 인텐트로만 열 수 있습니다.
>
> **8. 다른 앱 실행**: 카카오톡 같은 특정 앱을 패키지명으로 실행하거나, 없으면 플레이스토어로 유도하는 패턴입니다.
>
> **핵심**: 이런 시나리오들은 **Android 플랫폼의 표준 Intent 시스템을 사용**해야 하므로 Glance의 고수준 래퍼로는 불가능합니다. `action()`은 이런 **플랫폼 수준의 통합**을 가능하게 하는 강력한 탈출구입니다."

#### 2.5.4 사용 시 주의사항

**✅ 권장 사용 케이스**
- 시스템 인텐트 (전화, 브라우저, 알람, 설정 등)
- 써드파티 앱 통합 (딥링크, 공유)
- PendingIntent 플래그 커스터마이징
- 래퍼 API로 불가능한 특수 케이스

**❌ 피해야 할 케이스**
- 앱 내 Activity 실행 → `actionStartActivity` 사용
- 위젯 상태 변경 → `actionRunCallback` 사용
- 앱 내 Broadcast → `actionSendBroadcast` 사용

**보안 고려사항**
```kotlin
// ❌ 잘못된 예: exported가 true인 PendingIntent (보안 위험)
val unsafeIntent = Intent(context, MyActivity::class.java)
val pendingIntent = PendingIntent.getActivity(
    context, 0, unsafeIntent,
    PendingIntent.FLAG_MUTABLE // ⚠️ 위험: 다른 앱이 수정 가능
)

// ✅ 올바른 예: FLAG_IMMUTABLE 사용 (Android 12+)
val safeIntent = Intent(context, MyActivity::class.java)
val pendingIntent = PendingIntent.getActivity(
    context, 0, safeIntent,
    PendingIntent.FLAG_IMMUTABLE // ✅ 안전: 수정 불가
)
```

> [!WARNING]
> **Android 12 (API 31) 이상에서는 PendingIntent 생성 시 `FLAG_IMMUTABLE` 또는 `FLAG_MUTABLE`을 명시해야 합니다.** 명시하지 않으면 크래시가 발생합니다. 보안을 위해 가능하면 `FLAG_IMMUTABLE`을 사용하세요.

---

## 3. `ActionParameters`로 데이터 전달

`ActionCallback`에 파라미터를 전달할 수 있습니다.

```kotlin
// 1. 파라미터 정의
val itemIdKey = ActionParameters.Key<Int>("item_id")

// 2. 클릭 시 파라미터 전달
Button(
    text = "항목 삭제",
    onClick = actionRunCallback<DeleteItemAction>(
        parameters = actionParametersOf(itemIdKey to itemId)
    )
)

// 3. ActionCallback에서 파라미터 수신
class DeleteItemAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val itemId = parameters[itemIdKey] ?: return

        // 삭제 로직
        deleteItem(itemId)

        // UI 갱신
        MyWidget().update(context, glanceId)
    }
}
```

> [!NOTE] 💬 발표 설명
> "**ActionParameters는 RemoteViews의 PendingIntent 제약을 우회하는 방법**입니다.
>
> RemoteViews는 일반적인 Compose처럼 람다로 데이터를 전달할 수 없습니다. 모든 것이 PendingIntent를 통해야 하니까요. 그래서 Glance는 **Key-Value 시스템**을 제공합니다.
>
> 1. **Key 정의**: `ActionParameters.Key<Int>("item_id")` - 타입 안전한 키를 만듭니다.
> 2. **전달**: `actionParametersOf(itemIdKey to itemId)` - 클릭할 때 데이터를 함께 보냅니다.
> 3. **수신**: `parameters[itemIdKey]` - ActionCallback에서 안전하게 꺼냅니다.
>
> 이렇게 하면 리스트 위젯에서 **어떤 항목을 클릭했는지** 구분할 수 있습니다. 같은 ActionCallback 클래스를 재사용하면서도 다른 데이터를 처리할 수 있죠."

**[스크린샷 추천]** 리스트 위젯에서 각 항목의 삭제 버튼 예시

---

## 4. 복합 Action 패턴

### 4.1 조건부 Action
```kotlin
Button(
    text = if (isLoggedIn) "로그아웃" else "로그인",
    onClick = if (isLoggedIn) {
        actionRunCallback<LogoutAction>()
    } else {
        actionStartActivity<LoginActivity>()
    }
)
```

### 4.2 여러 컴포넌트에 동일 Action
```kotlin
@Composable
fun ClickableCard(data: String) {
    Box(
        modifier = GlanceModifier
            .fillMaxWidth()
            .padding(8.dp)
            .background(Color.White)
            .clickable(
                onClick = actionRunCallback<CardClickAction>(
                    parameters = actionParametersOf(dataKey to data)
                )
            )
    ) {
        Text(data)
    }
}
```

---

## 5. Action 처리 시 주의사항

### 5.1 상태 변경 후 반드시 `update()` 호출

상태를 변경한 후에는 **반드시 `update()`를 호출**해야 UI에 반영됩니다.

```kotlin
updateAppWidgetState(context, glanceId) { prefs ->
    prefs[someKey] = newValue
}
MyWidget().update(context, glanceId) // 필수!
```

> [!NOTE] 💬 발표 설명
> "**가장 흔한 실수**가 바로 `update()` 호출을 까먹는 겁니다.
>
> `updateAppWidgetState()`는 DataStore에 데이터만 저장합니다. 파일에 쓰는 것과 비슷해요. **화면 갱신과는 별개입니다.**
>
> `update()`를 호출해야 `provideGlance()`가 다시 실행되고, `currentState<Preferences>()`로 새로운 값을 읽어와서 UI가 다시 그려집니다.
>
> 이 두 단계가 분리된 이유는 **배치 업데이트**를 가능하게 하기 위해서입니다. 여러 상태를 한 번에 바꾸고 마지막에 딱 한 번만 `update()`를 호출하면 되니까요."

**업데이트 메서드에 대한 자세한 내용은 → [3. Glance 생명주기 & 업데이트 트리거⭐⭐](3.%20Glance%20생명주기%20&%20업데이트%20트리거⭐⭐.md)** 참고

### 5.2 무거운 작업은 `Worker`로 분리
```kotlin
class HeavyAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // ✅ 네트워크/DB 작업은 WorkManager로
        val workRequest = OneTimeWorkRequestBuilder<DataSyncWorker>()
            .setInputData(workDataOf("glance_id" to glanceId.toString()))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)

        // 즉시 로딩 상태 표시
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[booleanPreferencesKey("is_loading")] = true
        }
        MyWidget().update(context, glanceId)
    }
}
```

**[비디오 추천]** 버튼 클릭 → 로딩 표시 → 데이터 로드 완료 → 결과 표시 흐름

---

### 5.3 에러 처리
```kotlin
class SafeAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        try {
            // 작업 수행
            performTask()

            updateAppWidgetState(context, glanceId) { prefs ->
                prefs[stringPreferencesKey("status")] = "success"
            }
        } catch (e: Exception) {
            Log.e("SafeAction", "Error", e)
            updateAppWidgetState(context, glanceId) { prefs ->
                prefs[stringPreferencesKey("status")] = "error"
                prefs[stringPreferencesKey("error_msg")] = e.message ?: "Unknown"
            }
        } finally {
            MyWidget().update(context, glanceId)
        }
    }
}
```

---

## 6. 실전 예제: Todo 위젯

```kotlin
class TodoWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val prefs = currentState<Preferences>()
            val todos = prefs[stringPreferencesKey("todos")]?.split("|") ?: emptyList()

            Column(
                modifier = GlanceModifier.fillMaxSize().padding(16.dp)
            ) {
                Text("할 일 목록", style = TextStyle(fontSize = 18.sp, fontWeight = FontWeight.Bold))
                Spacer(GlanceModifier.height(8.dp))

                todos.forEach { todo ->
                    Row(
                        modifier = GlanceModifier.fillMaxWidth().padding(vertical = 4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(todo, modifier = GlanceModifier.defaultWeight())
                        Button(
                            text = "완료",
                            onClick = actionRunCallback<CompleteTodoAction>(
                                parameters = actionParametersOf(todoKey to todo)
                            )
                        )
                    }
                }

                Button(
                    text = "+ 추가",
                    onClick = actionStartActivity<AddTodoActivity>(),
                    modifier = GlanceModifier.fillMaxWidth()
                )
            }
        }
    }
}

class CompleteTodoAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val todoToRemove = parameters[todoKey] ?: return

        updateAppWidgetState(context, glanceId) { prefs ->
            val todos = prefs[stringPreferencesKey("todos")]?.split("|")?.toMutableList() ?: mutableListOf()
            todos.remove(todoToRemove)
            prefs[stringPreferencesKey("todos")] = todos.joinToString("|")
        }

        TodoWidget().update(context, glanceId)
    }
}

private val todoKey = ActionParameters.Key<String>("todo_item")
```

**[스크린샷 추천]** Todo 위젯 전체 UI (목록 + 완료 버튼 + 추가 버튼)

---

---
