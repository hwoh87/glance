> [!TIP] 🗣️ 핵심내용
Compose와 유사하지만 다른 Glance만의 컴포저블과 제약사항을 살펴봅니다.
>

## 1. Glance DSL 개요

Glance는 Compose와 **비슷하지만 다른** DSL입니다. 내부적으로 RemoteViews로 변환되기 때문에 여러 제약사항이 있습니다.

### 1.0 왜 제약이 있는가? (RemoteViews 기반)

```
🎨 Glance 렌더링 흐름
개발자: Glance DSL 작성 (Compose 스타일)
       ↓
Glance: 자동으로 RemoteViews 변환 ⚙️
       ↓
시스템: RemoteViews → AppWidgetHostView
       ↓
화면: 실제 위젯 UI 표시
```

> [!NOTE] 💬 발표 설명
> "**왜 제약이 있을까요?** Glance는 겉으로는 Compose처럼 보이지만, 실제로는 **RemoteViews**로 변환됩니다.
>
> RemoteViews는 Android 위젯 시스템의 근간이에요. 별도 프로세스에서 실행되는 UI를 표현하기 위한 '시리얼라이즈 가능한 UI 구조체'입니다. 일반 View처럼 메모리에 객체가 있는 게 아니라, **설명서(description)**를 전달하는 방식이죠.
>
> 그래서 Compose의 모든 기능을 쓸 수 없습니다:
> - ❌ `remember`: 상태를 메모리에 유지할 수 없음 (프로세스가 수시로 종료됨)
> - ❌ `LaunchedEffect`: 코루틴 실행 불가 (시리얼라이즈 불가)
> - ❌ 복잡한 애니메이션: RemoteViews가 지원하지 않음
>
> Glance는 이런 RemoteViews의 한계를 가진 채로, **최대한 Compose스럽게** 쓸 수 있도록 도와주는 래퍼입니다."

**핵심**: Glance DSL → (자동 변환) → RemoteViews → 위젯 UI

```xml

### 1.1 전통 위젯과의 UI 작성 방식 비교

**전통 위젯 (XML + RemoteViews)**
```xml
<!-- res/layout/widget_layout.xml -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    android:background="#FFFFFF">

    <TextView
        android:id="@+id/title_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        android:textStyle="bold" />

    <Button
        android:id="@+id/action_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Click Me" />
</LinearLayout>
```

```kotlin
// RemoteViews로 수동 조작
class TraditionalWidget : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        appWidgetIds.forEach { appWidgetId ->
            val views = RemoteViews(context.packageName, R.layout.widget_layout)

            // 텍스트 설정
            views.setTextViewText(R.id.title_text, "Hello Widget")

            // 클릭 이벤트
            val intent = Intent(context, RefreshAction::class.java)
            val pendingIntent = PendingIntent.getBroadcast(
                context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT
            )
            views.setOnClickPendingIntent(R.id.action_button, pendingIntent)

            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}
```

**Glance 위젯 (Compose DSL)**
```kotlin
// XML 불필요, 선언형 DSL로 직접 작성
class ModernWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            Column(
                modifier = GlanceModifier
                    .fillMaxSize()
                    .padding(16.dp)
                    .background(Color.White)
            ) {
                Text(
                    text = "Hello Widget",
                    style = TextStyle(fontSize = 18.sp, fontWeight = FontWeight.Bold)
                )

                Button(
                    text = "Click Me",
                    onClick = actionRunCallback<RefreshAction>()
                )
            }
        }
    }
}
```

**핵심 차이점**:
- **전통 방식**: XML 레이아웃 + RemoteViews API로 수동 조작
- **Glance 방식**: Compose 스타일 DSL로 선언적 UI 작성 (XML 불필요)
- **개발 경험**: 보일러플레이트 대폭 감소, 타입 안정성 향상

---

## 2. 사용 가능한 컴포저블

### 2.1 레이아웃 컴포넌트

#### Column
```kotlin
Column(
    modifier = GlanceModifier
        .fillMaxSize()
        .padding(16.dp),
    verticalAlignment = Alignment.CenterVertically,
    horizontalAlignment = Alignment.CenterHorizontally
) {
    Text("Item 1")
    Text("Item 2")
    Text("Item 3")
}
```

#### Row
```kotlin
Row(
    modifier = GlanceModifier.fillMaxWidth(),
    verticalAlignment = Alignment.CenterVertically,
    horizontalAlignment = Alignment.Start
) {
    Image(ImageProvider(R.drawable.icon), contentDescription = "Icon")
    Spacer(GlanceModifier.width(8.dp))
    Text("Label")
}
```

#### Box
```kotlin
Box(
    modifier = GlanceModifier.size(100.dp),
    contentAlignment = Alignment.Center
) {
    // 겹쳐서 배치
    Image(ImageProvider(R.drawable.background), contentDescription = null)
    Text("Overlay Text")
}
```

---

### 2.2 기본 UI 컴포넌트

#### Text
```kotlin
Text(
    text = "Hello, Glance!",
    style = TextStyle(
        fontSize = 18.sp,
        fontWeight = FontWeight.Bold,
        color = ColorProvider(Color.Black),
        textAlign = TextAlign.Center
    ),
    maxLines = 2
)
```

#### Image
```kotlin
// 리소스에서
Image(
    provider = ImageProvider(R.drawable.icon),
    contentDescription = "Icon",
    modifier = GlanceModifier.size(48.dp)
)

// URI에서
Image(
    provider = ImageProvider(Uri.parse("content://...")),
    contentDescription = "Profile",
    contentScale = ContentScale.Crop
)

// Bitmap (메모리 주의)
Image(
    provider = ImageProvider(bitmap),
    contentDescription = "Dynamic"
)
```

#### Button
```kotlin
Button(
    text = "새로고침",
    onClick = actionRunCallback<RefreshAction>(),
    modifier = GlanceModifier.fillMaxWidth(),
    style = TextStyle(fontSize = 14.sp),
    enabled = true
)
```

#### Spacer
```kotlin
Column {
    Text("First")
    Spacer(GlanceModifier.height(16.dp))
    Text("Second")
}
```

---

### 2.3 Material3 컴포넌트 (glance-material3 필요)

```kotlin
import androidx.glance.material3.*

// Material3 Button
Button(
    text = "Material Button",
    onClick = actionRunCallback<MyAction>(),
    colors = ButtonDefaults.buttonColors()
)

// CircularProgressIndicator
CircularProgressIndicator()

// LinearProgressIndicator
LinearProgressIndicator(
    progress = 0.7f,
    modifier = GlanceModifier.fillMaxWidth()
)

// Switch
Switch(
    checked = isEnabled,
    onCheckedChange = actionRunCallback<ToggleAction>(),
    text = "Enable Feature"
)

// CheckBox
CheckBox(
    checked = isSelected,
    onCheckedChange = actionRunCallback<SelectAction>(),
    text = "Agree to terms"
)
```

**[스크린샷 추천]** Material3 컴포넌트 모음 (Button, Switch, CheckBox, Progress)

---

## 3. Modifier 시스템

### 3.1 사용 가능한 Modifier

```kotlin
GlanceModifier
    // 크기
    .fillMaxSize()
    .fillMaxWidth()
    .fillMaxHeight()
    .width(100.dp)
    .height(50.dp)
    .size(48.dp)
    .defaultWeight()  // Row/Column에서 남은 공간 차지

    // 간격
    .padding(16.dp)
    .padding(horizontal = 16.dp, vertical = 8.dp)
    .padding(start = 8.dp, top = 4.dp, end = 8.dp, bottom = 4.dp)

    // 배경
    .background(Color.White)
    .background(ImageProvider(R.drawable.bg))

    // 테두리
    .border(width = 2.dp, color = Color.Black)
    .cornerRadius(8.dp)

    // 클릭
    .clickable(onClick = actionRunCallback<MyAction>())

    // 가시성
    .visibility(visible = isVisible)
```

---

### 3.2 사용 불가능한 Modifier

```kotlin
// ❌ Compose에는 있지만 Glance에는 없음
.rotate(45f)              // 회전 불가
.scale(1.5f)              // 스케일 불가
.alpha(0.5f)              // 투명도 조절 제한적
.offset(x = 10.dp)        // 오프셋 불가
.blur(radius = 4.dp)      // 블러 불가
.shadow(elevation = 8.dp) // 그림자 불가
.clip(CircleShape)        // 복잡한 클리핑 불가
```

---

## 4. 제약사항

### 4.1 Compose 런타임 API 사용 불가

```kotlin
// ❌ 모두 사용 불가
provideContent {
    var count by remember { mutableStateOf(0) }  // remember 불가

    LaunchedEffect(Unit) {  // LaunchedEffect 불가
        delay(1000)
    }

    DisposableEffect(Unit) {  // DisposableEffect 불가
        onDispose { }
    }

    val context = LocalContext.current  // LocalContext 제한적

    derivedStateOf { }  // derivedStateOf 불가
}
```

> [!NOTE] 💬 발표 설명
> "Glance DSL이 Compose처럼 보이지만, **Compose 런타임을 사용하지 않습니다**. 이게 가장 중요한 제약사항입니다.
>
> `remember`로 상태를 만들 수 없고, `LaunchedEffect`로 비동기 작업을 할 수 없습니다. Glance는 결국 RemoteViews로 변환되기 때문에, Compose의 런타임 기능들을 쓸 수 없는 거죠.
>
> 그럼 상태는 어떻게 관리하냐? `currentState()`로 읽고, `updateAppWidgetState()`로 쓰면 됩니다. 이건 DataStore 기반이라 안전하고, 위젯 재시작 후에도 유지됩니다."

**해결책**: 상태는 `currentState()` + `updateAppWidgetState()` 사용

```kotlin
// ✅ Glance 방식
provideContent {
    val prefs = currentState<Preferences>()
    val count = prefs[intPreferencesKey("count")] ?: 0

    Column {
        Text("Count: $count")
        Button(
            text = "+1",
            onClick = actionRunCallback<IncrementAction>()
        )
    }
}
```

---

### 4.2 제한된 레이아웃

```kotlin
// ✅ 지원되는 레이아웃
LazyColumn { }           // ✅ 세로 스크롤 리스트 지원 (런처에 따라 동작 제한 가능)
Scaffold { }             // ✅ Glance 1.1+ 지원

// ❌ 사용 불가
LazyRow { }              // ❌ 가로 스크롤 리스트 미지원
ConstraintLayout { }     // ❌ RemoteViews 제약으로 미지원
```

> [!NOTE] 💬 LazyColumn 사용 시 주의사항
> LazyColumn은 Glance에서 지원되지만, 런처에 따라 스크롤 동작이 제한될 수 있습니다. 일부 런처에서는 스크롤이 원활하지 않거나, 항목이 많을 경우 성능 이슈가 발생할 수 있으므로, 항목 수를 제한하거나 고정 레이아웃을 고려하세요.

```kotlin
// ✅ LazyColumn 사용 예제 (런처 지원 시)
LazyColumn {
    items(todoList) { todo ->
        TodoItem(todo)
    }
}

// ✅ 대안: 제한된 항목 수로 고정 레이아웃 (호환성 우선)
Column {
    items.take(5).forEach { item ->  // 최대 5개만 표시
        ItemRow(item)
    }
    if (items.size > 5) {
        Text("... ${items.size - 5}개 더")
    }
}
```

**[스크린샷 추천]** 고정된 항목 수 위젯 (5개 + "... N개 더" 메시지)

---

### 4.3 애니메이션 제약

```kotlin
// ❌ 직접 애니메이션 불가
animate* { }
Animatable
Transition
```

**대안**: 상태 변경으로 UI를 단계적으로 업데이트

```kotlin
// ✅ 단계적 상태 업데이트로 유사 애니메이션
class AnimateProgressAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        for (progress in 0..100 step 10) {
            updateAppWidgetState(context, glanceId) { prefs ->
                prefs[intPreferencesKey("progress")] = progress
            }
            MyWidget().update(context, glanceId)
            delay(100)  // 100ms 간격
        }
    }
}
```

---

### 4.4 단위 차이

```kotlin
// ❌ Compose의 dp
import androidx.compose.ui.unit.dp  // 위젯에서 사용 불가!

// ✅ Glance의 dp
import androidx.glance.unit.dp  // 반드시 이걸 사용

Text(
    text = "Hello",
    style = TextStyle(fontSize = 16.sp)  // sp는 동일
)
```

> [!NOTE] 💬 발표 설명
> "실수하기 쉬운 부분이 **단위**입니다.
>
> Compose에서 쓰던 `androidx.compose.ui.unit.dp`를 import하면 컴파일 에러가 납니다. Glance에서는 반드시 `androidx.glance.unit.dp`를 사용해야 합니다.
>
> 이건 Glance가 Compose와 별개의 시스템이라는 걸 보여주는 좋은 예시입니다. 비슷해 보이지만 근본적으로 다른 라이브러리죠.
>
> `sp`는 동일하게 사용할 수 있습니다."

---

## 5. 이미지 처리

### 5.1 이미지 소스

```kotlin
// ✅ 리소스 (권장)
ImageProvider(R.drawable.icon)

// ✅ URI
ImageProvider(Uri.parse("content://media/external/images/media/123"))

// ✅ Bitmap (작은 이미지만)
ImageProvider(smallBitmap)
```

> [!WARNING] 🚫 provideContent 내부에서 Coil/Glide 직접 사용 불가
> **provideContent 내부 (UI 선언 단계)**:
> - ❌ Coil/Glide 같은 일반 Android View 기반 라이브러리 사용 불가
> - ❌ RemoteViews로 변환되는 단계이므로 Glance DSL만 사용 가능
>
> **Worker/ActionCallback (위젯 외부)**:
> - ✅ Coil/Glide 사용 가능!
> - ✅ 백그라운드 작업이므로 일반 Android API 모두 사용 가능
> - ✅ 이미지 다운로드 후 파일/URI/Bitmap으로 변환하여 전달

### 5.2 네트워크 이미지 로딩

> [!TIP] 💡 핵심 패턴
> Worker에서 Glide/Coil로 이미지 다운로드 → 파일 저장 → URI를 DataStore에 저장 → provideContent에서 URI로 표시

```kotlin
class LoadImageWorker(context: Context, params: WorkerParameters)
    : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        val imageUrl = inputData.getString("image_url") ?: return Result.failure()
        val glanceId = inputData.getString("glance_id") ?: return Result.failure()

        return try {
            // 1. ✅ Worker에서는 Glide 사용 가능!
            val bitmap = Glide.with(applicationContext)
                .asBitmap()
                .load(imageUrl)
                .override(200, 200)  // 리사이즈
                .submit()
                .get()

            // 2. 파일로 저장
            val file = File(applicationContext.cacheDir, "widget_image_$glanceId.png")
            file.outputStream().use { out ->
                bitmap.compress(Bitmap.CompressFormat.PNG, 90, out)
            }

            // 3. 상태 업데이트 (URI 저장)
            val uri = FileProvider.getUriForFile(
                applicationContext,
                "${applicationContext.packageName}.fileprovider",
                file
            )

            updateAppWidgetState(applicationContext, glanceId.toGlanceId()) { prefs ->
                prefs[stringPreferencesKey("image_uri")] = uri.toString()
            }

            MyWidget().update(applicationContext, glanceId.toGlanceId())

            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
}

// ❌ provideContent에서는 Glide 사용 불가
// ✅ Worker에서 준비한 URI를 사용
provideContent {
    val prefs = currentState<Preferences>()
    val imageUriString = prefs[stringPreferencesKey("image_uri")]

    if (imageUriString != null) {
        Image(
            provider = ImageProvider(Uri.parse(imageUriString)),
            contentDescription = "Downloaded",
            modifier = GlanceModifier.size(100.dp)
        )
    } else {
        CircularProgressIndicator()
    }
}
```

**[비디오 추천]** Worker가 이미지 다운로드 → 위젯에 표시되는 과정

---

## 6. 반응형 UI 패턴

### 6.1 크기 기반 분기

```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        val size = LocalSize.current

        when {
            size.width < 150.dp -> CompactUI()
            size.width < 250.dp -> MediumUI()
            else -> ExpandedUI()
        }
    }
}

@Composable
fun CompactUI() {
    Box(
        modifier = GlanceModifier.fillMaxSize().background(Color.LightGray),
        contentAlignment = Alignment.Center
    ) {
        Text("S", style = TextStyle(fontSize = 24.sp))
    }
}

@Composable
fun MediumUI() {
    Column(
        modifier = GlanceModifier.fillMaxSize().padding(8.dp)
    ) {
        Text("Medium", style = TextStyle(fontSize = 16.sp))
        Spacer(GlanceModifier.height(4.dp))
        Button("Action", onClick = actionRunCallback<MyAction>())
    }
}

@Composable
fun ExpandedUI() {
    Row(
        modifier = GlanceModifier.fillMaxSize().padding(16.dp)
    ) {
        Column(modifier = GlanceModifier.defaultWeight()) {
            Text("Left Panel", style = TextStyle(fontSize = 18.sp, fontWeight = FontWeight.Bold))
            Text("More content here")
        }
        Spacer(GlanceModifier.width(16.dp))
        Column(modifier = GlanceModifier.defaultWeight()) {
            Text("Right Panel")
            Button("Action 1", onClick = actionRunCallback<Action1>())
            Button("Action 2", onClick = actionRunCallback<Action2>())
        }
    }
}
```

**[스크린샷 추천]** 3가지 크기별 UI 변화 (Compact, Medium, Expanded)

---

### 6.2 상태 기반 UI

```kotlin
@Composable
fun DynamicContent() {
    val prefs = currentState<Preferences>()
    val status = prefs[stringPreferencesKey("status")] ?: "idle"
    val data = prefs[stringPreferencesKey("data")]

    when (status) {
        "loading" -> LoadingState()
        "success" -> SuccessState(data ?: "")
        "error" -> ErrorState(prefs[stringPreferencesKey("error_msg")])
        else -> IdleState()
    }
}

@Composable
fun LoadingState() {
    Box(
        modifier = GlanceModifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            CircularProgressIndicator()
            Spacer(GlanceModifier.height(8.dp))
            Text("로딩 중...")
        }
    }
}

@Composable
fun SuccessState(data: String) {
    Column(
        modifier = GlanceModifier.fillMaxSize().padding(16.dp)
    ) {
        Text("✅ 성공", style = TextStyle(fontWeight = FontWeight.Bold))
        Spacer(GlanceModifier.height(8.dp))
        Text(data)
        Spacer(GlanceModifier.defaultWeight())
        Button("새로고침", onClick = actionRunCallback<RefreshAction>())
    }
}

@Composable
fun ErrorState(message: String?) {
    Column(
        modifier = GlanceModifier.fillMaxSize().padding(16.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("❌ 오류", style = TextStyle(color = ColorProvider(Color.Red), fontWeight = FontWeight.Bold))
        Spacer(GlanceModifier.height(8.dp))
        Text(message ?: "알 수 없는 오류")
        Spacer(GlanceModifier.height(16.dp))
        Button("재시도", onClick = actionRunCallback<RetryAction>())
    }
}
```

---

## 7. 접근성

### 7.1 contentDescription

```kotlin
// ✅ 모든 이미지와 버튼에 설명 추가
Image(
    provider = ImageProvider(R.drawable.weather_sunny),
    contentDescription = "맑은 날씨"  // TalkBack이 읽음
)

Button(
    text = "새로고침",
    onClick = actionRunCallback<RefreshAction>(),
    modifier = GlanceModifier.semantics {
        contentDescription = "날씨 정보 새로고침 버튼"
    }
)
```

### 7.2 의미 있는 텍스트

```kotlin
// ❌ 아이콘만 표시
Button(
    text = "↻",
    onClick = actionRunCallback<RefreshAction>()
)

// ✅ 텍스트로 명확히 표현
Button(
    text = "새로고침",
    onClick = actionRunCallback<RefreshAction>()
)
```

---

## 8. 성능 권장사항

### 8.1 UI 복잡도 제한

```kotlin
// ❌ 너무 복잡
Column {
    repeat(50) { index ->
        Row {
            Image(ImageProvider(R.drawable.icon))
            Column {
                Text("Item $index")
                Row {
                    Button("A", onClick = {})
                    Button("B", onClick = {})
                    Button("C", onClick = {})
                }
            }
        }
    }
}

// ✅ 단순하고 효율적
Column {
    repeat(5) { index ->  // 항목 개수 제한
        Row(verticalAlignment = Alignment.CenterVertically) {
            Image(ImageProvider(R.drawable.icon), contentDescription = null)
            Spacer(GlanceModifier.width(8.dp))
            Text("Item $index", modifier = GlanceModifier.defaultWeight())
        }
    }
    if (totalItems > 5) {
        Text("... ${totalItems - 5}개 더", style = TextStyle(fontSize = 12.sp))
    }
}
```

### 8.2 조건부 렌더링

```kotlin
@Composable
fun OptimizedWidget() {
    val prefs = currentState<Preferences>()
    val showDetails = prefs[booleanPreferencesKey("show_details")] ?: false

    Column {
        Text("Title")

        // 필요할 때만 렌더링
        if (showDetails) {
            DetailSection()  // 무거운 컴포넌트
        }
    }
}
```

---

---
