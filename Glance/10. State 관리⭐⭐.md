> [!TIP] 🗣️ 핵심내용
위젯의 상태를 저장하고 복원하는 방법. `currentState()`, `updateAll()`, `update()`를 활용한 데이터 관리를 배웁니다.
>

## 1. State 관리 개요

Glance 위젯은 **인스턴스별로 독립적인 상태**를 가질 수 있습니다. 홈 화면에 같은 위젯을 여러 개 추가하면 각각 다른 데이터를 보여줄 수 있다는 의미입니다.

```
📱 홈 화면
   ├─ 위젯 A (`GlanceId`: 123) → State A
   ├─ 위젯 B (`GlanceId`: 456) → State B
   └─ 위젯 C (`GlanceId`: 789) → State C
```

### 1.1 전통 위젯과의 상태 관리 비교

**전통 위젯 (SharedPreferences 직접 구현)**
```kotlin
class TraditionalWidget : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        appWidgetIds.forEach { appWidgetId ->
            // 1. SharedPreferences에서 수동으로 상태 읽기
            val prefs = context.getSharedPreferences("widget_$appWidgetId", Context.MODE_PRIVATE)
            val count = prefs.getInt("count", 0)
            val name = prefs.getString("name", "Guest") ?: "Guest"

            // 2. RemoteViews 생성 및 설정
            val views = RemoteViews(context.packageName, R.layout.widget_layout)
            views.setTextViewText(R.id.count_text, "Count: $count")
            views.setTextViewText(R.id.name_text, "Name: $name")

            // 3. 버튼 클릭 시 BroadcastReceiver로 전달
            val intent = Intent(context, IncrementReceiver::class.java)
            intent.putExtra("widget_id", appWidgetId)
            val pendingIntent = PendingIntent.getBroadcast(
                context, appWidgetId, intent, PendingIntent.FLAG_UPDATE_CURRENT
            )
            views.setOnClickPendingIntent(R.id.increment_button, pendingIntent)

            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}

// 별도 BroadcastReceiver로 상태 변경 처리
class IncrementReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val widgetId = intent.getIntExtra("widget_id", -1)

        // 1. SharedPreferences에서 읽기
        val prefs = context.getSharedPreferences("widget_$widgetId", Context.MODE_PRIVATE)
        val currentCount = prefs.getInt("count", 0)

        // 2. 상태 변경
        prefs.edit().putInt("count", currentCount + 1).apply()

        // 3. 위젯 수동 업데이트
        val appWidgetManager = AppWidgetManager.getInstance(context)
        val views = RemoteViews(context.packageName, R.layout.widget_layout)
        views.setTextViewText(R.id.count_text, "Count: ${currentCount + 1}")
        appWidgetManager.updateAppWidget(widgetId, views)
    }
}
```

**문제점**:
- SharedPreferences 파일명 관리 (`widget_$appWidgetId`)를 직접 해야 함
- 상태 읽기/쓰기 로직이 여러 곳에 분산 (AppWidgetProvider, BroadcastReceiver 등)
- 인스턴스별 상태 분리를 수동으로 구현해야 함
- 타입 안정성 부족 (문자열 키 사용)
- 상태 변경 후 UI 업데이트를 수동으로 처리

**Glance 위젯 (DataStore 기반 StateDefinition)**
```kotlin
class ModernWidget : GlanceAppWidget() {
    // StateDefinition 지정만으로 상태 관리 준비 완료
    override val stateDefinition = PreferencesGlanceStateDefinition

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // 1. 상태 읽기 - 인스턴스별 자동 분리
            val prefs = currentState<Preferences>()
            val count = prefs[intPreferencesKey("count")] ?: 0
            val name = prefs[stringPreferencesKey("name")] ?: "Guest"

            Column {
                Text("Count: $count")
                Text("Name: $name")

                // 2. 버튼 클릭 시 ActionCallback으로 처리
                Button(
                    text = "Increment",
                    onClick = actionRunCallback<IncrementAction>()
                )
            }
        }
    }
}

// 상태 변경 로직 - 타입 안정성 보장
class IncrementAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 상태 변경 - 인스턴스별 자동 관리
        updateAppWidgetState(context, glanceId) { prefs ->
            val current = prefs[intPreferencesKey("count")] ?: 0
            prefs[intPreferencesKey("count")] = current + 1
        }

        // 2. UI 업데이트 - 한 줄로 처리
        ModernWidget().update(context, glanceId)
    }
}
```

**개선점**:
- **인스턴스별 상태 자동 관리**: GlanceId 기반으로 자동 분리
- **DataStore 기반**: SharedPreferences보다 안전하고 비동기 친화적
- **타입 안정성**: `intPreferencesKey`, `stringPreferencesKey` 등으로 타입 보장
- **중앙화된 로직**: 상태 관리가 `updateAppWidgetState` + `update()`로 통일
- **코드 간결성**: 보일러플레이트 대폭 감소

**비교 요약**:

| 항목 | 전통 위젯 | Glance 위젯 |
|------|-----------|-------------|
| **상태 저장소** | SharedPreferences (직접 구현) | DataStore (자동 제공) |
| **인스턴스 분리** | `widget_$appWidgetId` 파일명 수동 관리 | `GlanceId` 자동 관리 |
| **타입 안정성** | 문자열 키 (타입 불안정) | Typed Key (타입 안정) |
| **상태 변경 흐름** | 읽기 → 변경 → 저장 → UI 업데이트 (4단계) | `updateAppWidgetState` + `update()` (2단계) |
| **코드 분산** | AppWidgetProvider, BroadcastReceiver 등 여러 곳 | ActionCallback 한 곳에 집중 |
| **비동기 지원** | 수동 구현 필요 | Coroutine 기반 자동 지원 |

---

## 2. `StateDefinition` 종류

### 2.1 `PreferencesGlanceStateDefinition` (가장 많이 사용)
- **간단한 key-value 데이터**에 적합
- DataStore Preferences 기반
- 타입: `Int`, `String`, `Boolean`, `Long`, `Float`, `Double`, `Set<String>`

```kotlin
class SimpleWidget : GlanceAppWidget() {
    // StateDefinition 지정
    override val stateDefinition = PreferencesGlanceStateDefinition

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // 1. 현재 상태 읽기
            val prefs = currentState<Preferences>()
            val count = prefs[intPreferencesKey("count")] ?: 0
            val name = prefs[stringPreferencesKey("name")] ?: "Guest"
            val isActive = prefs[booleanPreferencesKey("is_active")] ?: false

            Column {
                Text("Count: $count")
                Text("Name: $name")
                Text("Active: $isActive")
            }
        }
    }
}
```

---

### 2.2 `ProtoGlanceStateDefinition` (복잡한 데이터)
- **구조화된 데이터**에 적합
- Protocol Buffers 사용
- 타입 안정성 ↑, 직렬화 성능 ↑

**Step 1: proto 파일 정의**
```protobuf
// app/src/main/proto/widget_state.proto
syntax = "proto3";

option java_package = "com.example.widget";
option java_multiple_files = true;

message WidgetState {
    string title = 1;
    int32 counter = 2;
    repeated string items = 3;
}
```

**Step 2: build.gradle.kts 설정**
```kotlin
plugins {
    id("com.google.protobuf") version "0.9.4"
}

dependencies {
    implementation("androidx.datastore:datastore:1.0.0")
    implementation("com.google.protobuf:protobuf-javalite:3.21.12")
}

protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.21.12"
    }
    generateProtoTasks {
        all().forEach { task ->
            task.builtins {
                create("java") {
                    option("lite")
                }
            }
        }
    }
}
```

**Step 3: StateDefinition 구현**
```kotlin
object WidgetStateDefinition : GlanceStateDefinition<WidgetState> {
    private const val DATA_STORE_FILENAME = "widget_state"

    override suspend fun getDataStore(context: Context, fileKey: String): DataStore<WidgetState> {
        return context.dataStore
    }

    override fun getLocation(context: Context, fileKey: String): File {
        return context.dataStoreFile("$DATA_STORE_FILENAME$fileKey")
    }

    private val Context.dataStore by dataStore(
        fileName = DATA_STORE_FILENAME,
        serializer = WidgetStateSerializer
    )
}

object WidgetStateSerializer : Serializer<WidgetState> {
    override val defaultValue: WidgetState = WidgetState.getDefaultInstance()

    override suspend fun readFrom(input: InputStream): WidgetState {
        return WidgetState.parseFrom(input)
    }

    override suspend fun writeTo(t: WidgetState, output: OutputStream) {
        t.writeTo(output)
    }
}

// Widget에서 사용
class ProtoWidget : GlanceAppWidget() {
    override val stateDefinition = WidgetStateDefinition

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val state = currentState<WidgetState>()
            Column {
                Text("Title: ${state.title}")
                Text("Counter: ${state.counter}")
                state.itemsList.forEach { item ->
                    Text("- $item")
                }
            }
        }
    }
}
```

---

### 2.3 Custom StateDefinition
- 특수한 요구사항이 있을 때 직접 구현
- Room, File, Network 등 외부 소스 활용 가능

```kotlin
object RoomStateDefinition : GlanceStateDefinition<WidgetData> {
    override suspend fun getDataStore(
        context: Context,
        fileKey: String
    ): DataStore<WidgetData> {
        // Room이나 다른 저장소에서 데이터 가져오기
        return CustomDataStore(context, fileKey)
    }

    override fun getLocation(context: Context, fileKey: String): File {
        return File(context.filesDir, "room_state_$fileKey")
    }
}
```

---

## 3. 상태 읽기

### 3.1 currentState()
```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        // Preferences 방식
        val prefs = currentState<Preferences>()
        val value = prefs[intPreferencesKey("my_key")] ?: 0

        // Proto 방식
        val state = currentState<WidgetState>()
        val title = state.title

        Text("Value: $value, Title: $title")
    }
}
```

> [!NOTE] 💬 발표 설명
> "`currentState()`는 위젯의 현재 상태를 읽어오는 함수입니다.
>
> Preferences 방식을 쓰면 `Preferences` 타입을 받고, `intPreferencesKey`나 `stringPreferencesKey`로 값을 꺼냅니다. Proto 방식은 직접 정의한 데이터 클래스를 받아서 프로퍼티로 접근합니다.
>
> 중요한 건, 이 상태는 **위젯 인스턴스별로 독립적**이라는 점입니다. 같은 위젯을 3개 추가하면 각각 다른 `GlanceId`를 갖고, 각자의 상태를 따로 관리합니다.
>
> Compose의 `remember`와 비슷하지만, DataStore 기반이라 **프로세스 재시작 후에도 유지**됩니다."

---

## 4. 상태 쓰기

### 4.1 updateAppWidgetState (단일 위젯)
```kotlin
class IncrementAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // Preferences 방식
        updateAppWidgetState(context, glanceId) { prefs ->
            val current = prefs[intPreferencesKey("count")] ?: 0
            prefs[intPreferencesKey("count")] = current + 1
        }

        // Proto 방식 (복사 후 수정)
        updateAppWidgetState(context, glanceId) { state: WidgetState ->
            state.toBuilder()
                .setCounter(state.counter + 1)
                .build()
        }

        // 반드시 update() 호출!
        MyWidget().update(context, glanceId)
    }
}
```

> [!NOTE] 💬 발표 설명
> "상태를 변경하는 흐름은 **2단계**입니다.
>
> 1. **`updateAppWidgetState`로 상태 변경**: 람다 안에서 기존 값을 읽고, 새 값을 설정합니다. Preferences 방식은 mutable하게 직접 수정하고, Proto 방식은 불변 객체라서 빌더로 복사 후 수정합니다.
>
> 2. **`update()` 호출로 UI 갱신**: 상태만 바꿔서는 화면이 안 바뀝니다. 반드시 `MyWidget().update(context, glanceId)`를 호출해야 `provideContent`가 다시 실행되고 UI가 새로 그려집니다.
>
> 이 두 단계를 빼먹으면 안 됩니다. 상태는 바뀌었는데 화면은 그대로거나, 상태는 그대로인데 UI만 다시 그려지는 상황이 생길 수 있어요."

**[스크린샷 추천]** 상태 변경 전후 비교 (카운터 0 → 1)

---

### 4.2 updateAll (모든 위젯 인스턴스)
```kotlin
class RefreshAllAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 모든 위젯 인스턴스의 상태를 동일하게 변경
        val manager = GlanceAppWidgetManager(context)
        val glanceIds = manager.getGlanceIds(MyWidget::class.java)

        glanceIds.forEach { id ->
            updateAppWidgetState(context, id) { prefs ->
                prefs[longPreferencesKey("last_sync")] = System.currentTimeMillis()
            }
        }

        // 모든 위젯 UI 갱신
        MyWidget().updateAll(context)
    }
}
```

---

## 5. 실전 패턴

### 5.1 초기 상태 설정
```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    override val glanceAppWidget = MyWidget()

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        super.onUpdate(context, appWidgetManager, appWidgetIds)

        // 각 위젯 인스턴스에 초기 상태 설정
        appWidgetIds.forEach { appWidgetId ->
            val glanceId = GlanceAppWidgetManager(context)
                .getGlanceIdBy(appWidgetId)

            lifecycleScope.launch {
                updateAppWidgetState(context, glanceId) { prefs ->
                    if (!prefs.contains(intPreferencesKey("count"))) {
                        prefs[intPreferencesKey("count")] = 0
                    }
                    prefs[longPreferencesKey("created_at")] = System.currentTimeMillis()
                }
                MyWidget().update(context, glanceId)
            }
        }
    }
}
```

---

### 5.2 외부 데이터와 동기화 (Repository 패턴)
```kotlin
class DataSyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        // 1. API 호출
        val data = apiService.fetchData()

        // 2. 모든 위젯 상태 업데이트
        val manager = GlanceAppWidgetManager(applicationContext)
        val glanceIds = manager.getGlanceIds(MyWidget::class.java)

        glanceIds.forEach { glanceId ->
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                prefs[stringPreferencesKey("data")] = data.toString()
                prefs[longPreferencesKey("last_update")] = System.currentTimeMillis()
            }
        }

        // 3. UI 갱신
        MyWidget().updateAll(applicationContext)

        return Result.success()
    }
}
```

**[비디오 추천]** Worker 실행 → API 호출 → 위젯 상태 변경 → UI 자동 갱신 흐름

---

### 5.3 조건부 상태 변경
```kotlin
class ToggleAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        updateAppWidgetState(context, glanceId) { prefs ->
            val isEnabled = prefs[booleanPreferencesKey("is_enabled")] ?: false

            if (isEnabled) {
                // 비활성화
                prefs[booleanPreferencesKey("is_enabled")] = false
                prefs[stringPreferencesKey("status")] = "OFF"
            } else {
                // 활성화
                prefs[booleanPreferencesKey("is_enabled")] = true
                prefs[stringPreferencesKey("status")] = "ON"
                prefs[longPreferencesKey("enabled_at")] = System.currentTimeMillis()
            }
        }

        MyWidget().update(context, glanceId)
    }
}
```

---

### 5.4 상태 기반 UI 분기
```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        val prefs = currentState<Preferences>()
        val status = prefs[stringPreferencesKey("status")] ?: "idle"

        when (status) {
            "loading" -> LoadingUI()
            "success" -> SuccessUI(prefs)
            "error" -> ErrorUI(prefs[stringPreferencesKey("error_msg")])
            else -> IdleUI()
        }
    }
}

@Composable
fun LoadingUI() {
    Box(
        modifier = GlanceModifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator()
        Text("로딩 중...")
    }
}

@Composable
fun SuccessUI(prefs: Preferences) {
    val data = prefs[stringPreferencesKey("data")] ?: ""
    Column {
        Text("성공!", style = TextStyle(fontWeight = FontWeight.Bold))
        Text(data)
    }
}

@Composable
fun ErrorUI(message: String?) {
    Column {
        Text("오류 발생", style = TextStyle(color = ColorProvider(Color.Red)))
        Text(message ?: "알 수 없는 오류")
        Button("재시도", onClick = actionRunCallback<RetryAction>())
    }
}
```

**[스크린샷 추천]** 상태별 UI 변화 (idle, loading, success, error)

---

## 6. 상태 디버깅

### 6.1 현재 상태 로깅
```kotlin
class DebugAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val prefs = context
            .dataStoreFile("glance_${glanceId}")
            .let { DataStoreFactory.create(PreferencesSerializer, it) }
            .data
            .first()

        Log.d("WidgetState", "GlanceId: $glanceId")
        prefs.asMap().forEach { (key, value) ->
            Log.d("WidgetState", "  $key = $value")
        }
    }
}
```

### 6.2 상태 초기화 (테스트용)
```kotlin
class ResetAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs.clear()
            // 기본값 재설정
            prefs[intPreferencesKey("count")] = 0
            prefs[stringPreferencesKey("status")] = "idle"
        }

        MyWidget().update(context, glanceId)
    }
}
```

---

## 7. 상태 관리 베스트 프랙티스

### ✅ DO
- **작은 데이터만 저장** (수십 KB 이내)
- **상태 변경 후 즉시 update() 호출**
- **기본값 제공** (?: 0, ?: "default")
- **인스턴스별 독립성 유지** (GlanceId 활용)
- **무거운 데이터는 외부 저장소**(Room, File) + Glance에는 ID만 저장

### ❌ DON'T
- **대용량 데이터 저장 금지** (이미지, 긴 텍스트)
- **상태 변경만 하고 update() 생략**
- **동기화 블로킹 작업** (네트워크, DB)
- **상태에 민감 정보 저장** (토큰, 비밀번호)

---

## 8. 실전 예제: 날씨 위젯

```kotlin
data class WeatherData(
    val temperature: Int,
    val condition: String,
    val lastUpdate: Long
)

class WeatherWidget : GlanceAppWidget() {
    override val stateDefinition = PreferencesGlanceStateDefinition

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val prefs = currentState<Preferences>()
            val temp = prefs[intPreferencesKey("temperature")] ?: 0
            val condition = prefs[stringPreferencesKey("condition")] ?: "알 수 없음"
            val isLoading = prefs[booleanPreferencesKey("is_loading")] ?: false
            val lastUpdate = prefs[longPreferencesKey("last_update")] ?: 0L

            Column(
                modifier = GlanceModifier
                    .fillMaxSize()
                    .padding(16.dp)
                    .background(Color.LightGray)
            ) {
                if (isLoading) {
                    Text("날씨 정보 가져오는 중...")
                    CircularProgressIndicator()
                } else {
                    Text("🌤️ $condition", style = TextStyle(fontSize = 24.sp))
                    Text("$temp°C", style = TextStyle(fontSize = 48.sp, fontWeight = FontWeight.Bold))

                    Spacer(GlanceModifier.height(8.dp))

                    Text(
                        "최근 업데이트: ${formatTime(lastUpdate)}",
                        style = TextStyle(fontSize = 12.sp, color = ColorProvider(Color.Gray))
                    )
                }

                Spacer(GlanceModifier.defaultWeight())

                Button(
                    text = "새로고침",
                    onClick = actionRunCallback<RefreshWeatherAction>(),
                    modifier = GlanceModifier.fillMaxWidth()
                )
            }
        }
    }
}

class RefreshWeatherAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 로딩 상태로 변경
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[booleanPreferencesKey("is_loading")] = true
        }
        WeatherWidget().update(context, glanceId)

        // 2. Worker로 날씨 데이터 가져오기 (비동기)
        val workRequest = OneTimeWorkRequestBuilder<WeatherWorker>()
            .setInputData(workDataOf("glance_id" to glanceId.toString()))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)
    }
}

class WeatherWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        val glanceIdString = inputData.getString("glance_id") ?: return Result.failure()
        val glanceId = GlanceAppWidgetManager(applicationContext)
            .getGlanceIds(WeatherWidget::class.java)
            .find { it.toString() == glanceIdString }
            ?: return Result.failure()

        try {
            // API 호출
            val weather = weatherApi.getCurrentWeather()

            // 상태 업데이트
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                prefs[intPreferencesKey("temperature")] = weather.temp
                prefs[stringPreferencesKey("condition")] = weather.condition
                prefs[longPreferencesKey("last_update")] = System.currentTimeMillis()
                prefs[booleanPreferencesKey("is_loading")] = false
            }

            // UI 갱신
            WeatherWidget().update(applicationContext, glanceId)

            return Result.success()
        } catch (e: Exception) {
            // 에러 상태 저장
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                prefs[booleanPreferencesKey("is_loading")] = false
                prefs[stringPreferencesKey("condition")] = "오류"
            }
            WeatherWidget().update(applicationContext, glanceId)

            return Result.failure()
        }
    }
}
```

**[스크린샷 추천]** 날씨 위젯 전체 UI (온도, 날씨 상태, 마지막 업데이트 시간, 새로고침 버튼)

---

---
