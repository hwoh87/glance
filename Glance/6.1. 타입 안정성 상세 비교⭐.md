> [!TIP] 🗣️ 핵심내용
> 전통 위젯(SharedPreferences)과 Glance 위젯(DataStore)의 타입 안정성을 심층 비교합니다. 문자열 키의 문제점과 Typed Key의 장점을 상세하게 다룹니다.
>

## 개요

위젯 상태 관리에서 **타입 안정성**은 버그를 런타임이 아닌 컴파일 타임에 발견할 수 있게 해주는 핵심 요소입니다. 이 문서에서는 전통적인 SharedPreferences와 Glance DataStore의 타입 안정성을 심층 비교합니다.

> [!NOTE]
> 이 문서는 **[6. State 관리⭐⭐](6.%20State%20관리⭐⭐.md)** 문서의 보충 자료입니다. State 관리의 기본 개념을 먼저 학습한 후 이 문서를 읽는 것을 권장합니다.

---

## 1. 전통 위젯의 타입 불안정성 문제

전통적인 SharedPreferences는 **문자열 키**를 사용하여 값을 저장하고 읽습니다. 이로 인해 다음과 같은 타입 안정성 문제가 발생합니다.

### 문제 1: 타입 불일치 런타임 에러

```kotlin
// 저장할 때는 Int로 저장
val prefs = context.getSharedPreferences("widget", Context.MODE_PRIVATE)
prefs.edit().putInt("count", 42).apply()

// 나중에 실수로 String으로 읽으려고 시도
val count = prefs.getString("count", "0") // ❌ ClassCastException!
// 런타임 에러: java.lang.Integer cannot be cast to java.lang.String
```

**문제점**:
- 컴파일 타임에는 아무런 경고나 에러가 없음
- 앱이 실행되어 해당 코드가 실행될 때만 크래시 발생
- 사용자에게 직접 영향을 미치는 심각한 버그

---

### 문제 2: 키 오타로 인한 버그

```kotlin
// 저장할 때
prefs.edit().putInt("user_count", 10).apply()

// 읽을 때 (오타!)
val count = prefs.getInt("userCount", 0) // ❌ 0이 반환됨 (오타 감지 불가)
// 컴파일러가 오타를 잡지 못함!
```

**문제점**:
- `user_count`와 `userCount`는 다른 키로 인식됨
- 컴파일 에러 없이 조용히 기본값(0)이 반환됨
- 버그를 발견하기 매우 어려움 (값이 항상 0이 나오는데 이유를 모름)

---

### 문제 3: 타입 변경 시 안전하지 않음

```kotlin
// 초기 버전: Int로 저장
prefs.edit().putInt("settings", 1).apply()

// 나중에 요구사항 변경: String으로 변경하고 싶음
prefs.edit().putString("settings", "enabled").apply()

// 기존 코드가 Int로 읽으려고 하면?
val oldValue = prefs.getInt("settings", 0) // ❌ ClassCastException!
// 앱 크래시!
```

**문제점**:
- 타입을 변경하면 기존 코드에서 크래시 발생
- 모든 사용처를 수동으로 찾아서 수정해야 함
- 마이그레이션 로직이 복잡해짐

---

### 문제 4: IDE 자동완성 불가

```kotlin
// 문자열 키는 자동완성이 안 됨
val value1 = prefs.getInt("user_", 0) // IDE가 어떤 키가 있는지 모름
val value2 = prefs.getInt("user_count", 0) // 완전히 외워야 함
val value3 = prefs.getInt("use_count", 0) // 오타인지 아닌지 알 수 없음
```

**문제점**:
- 개발자가 모든 키 이름을 외워야 함
- 타이핑 실수가 쉽게 발생
- 코드 작성 속도 저하

---

### 문제 5: 리팩토링 위험

```kotlin
// 키 이름을 변경하고 싶을 때
// 1. 모든 사용처를 수동으로 찾아야 함
prefs.edit().putInt("count", value).apply() // 저장 1
val c1 = prefs.getInt("count", 0) // 읽기 1
val c2 = prefs.getInt("count", 0) // 읽기 2
val c3 = prefs.getInt("count", 0) // 읽기 3 (다른 파일)

// 2. Refactor > Rename이 작동하지 않음 (문자열이라서)
// 3. Find in Files로 수동 검색 필요
// 4. 놓치는 곳이 있으면 버그 발생
```

**문제점**:
- IntelliJ의 Refactor 기능을 사용할 수 없음
- 수동 검색으로 모든 사용처를 찾아야 함
- 누락된 곳이 있으면 런타임 버그 발생 (기본값 반환)

---

### 문제 6: 기본값 타입 불일치

```kotlin
// 저장은 Int로
prefs.edit().putInt("timeout", 5000).apply()

// 읽을 때 실수로 Long 기본값
val timeout = prefs.getLong("timeout", 5000L) // ❌ ClassCastException!
// 런타임 크래시!
```

**문제점**:
- 저장 타입과 읽기 타입이 달라도 컴파일 에러 없음
- 실행 시점에만 크래시 발생
- 특히 기본값의 타입을 잘못 지정하기 쉬움

---

## 2. Glance DataStore의 타입 안정성

Glance는 **Typed Key** 시스템으로 위의 모든 문제를 해결합니다.

### 해결책 1: 컴파일 타임 타입 체크

```kotlin
// 키를 정의할 때 타입이 고정됨
val countKey = intPreferencesKey("count") // Int 타입으로 고정
val nameKey = stringPreferencesKey("name") // String 타입으로 고정

// 저장할 때
updateAppWidgetState(context, glanceId) { prefs ->
    prefs[countKey] = 42 // ✅ Int만 가능
    prefs[countKey] = "text" // ❌ 컴파일 에러! Type mismatch
}

// 읽을 때
val count: Int? = prefs[countKey] // ✅ 반환 타입이 Int?로 고정
val wrong: String? = prefs[countKey] // ❌ 컴파일 에러! Type mismatch
```

**장점**:
- 타입 불일치는 **코드 작성 단계**에서 IDE가 빨간 밑줄로 표시
- 컴파일 자체가 안 되므로 런타임 크래시 원천 차단
- 개발 단계에서 즉시 수정 가능

---

### 해결책 2: 키 이름 중앙 관리 + 타입 안정성

```kotlin
// 키 정의를 한 곳에 모아서 관리
object WidgetKeys {
    val COUNT = intPreferencesKey("count")
    val NAME = stringPreferencesKey("name")
    val IS_ENABLED = booleanPreferencesKey("is_enabled")
    val LAST_UPDATE = longPreferencesKey("last_update")
    val TEMPERATURE = doublePreferencesKey("temperature")
}

// 사용할 때 - 오타 불가능!
updateAppWidgetState(context, glanceId) { prefs ->
    prefs[WidgetKeys.COUNT] = 10 // ✅ 자동완성 지원
    prefs[WidgetKeys.NAMEE] = "test" // ❌ 컴파일 에러! Unresolved reference
}

// 읽을 때도 타입 보장
val count = prefs[WidgetKeys.COUNT] ?: 0 // count는 Int 타입
val name = prefs[WidgetKeys.NAME] ?: "Guest" // name은 String 타입
```

**장점**:
- 모든 키를 한 곳에서 관리 → 중복 방지
- 오타 시 즉시 컴파일 에러 발생
- IDE 자동완성으로 빠른 코드 작성

---

### 해결책 3: 안전한 타입 변경

```kotlin
// 타입을 변경하고 싶으면 키 정의만 변경
object WidgetKeys {
    // 초기 버전
    val SETTINGS = intPreferencesKey("settings") // Int

    // 나중에 변경 결정
    val SETTINGS = stringPreferencesKey("settings_v2") // 키 이름도 변경
}

// 컴파일러가 모든 사용처를 체크해서 에러 표시
prefs[WidgetKeys.SETTINGS] = 1 // ❌ 컴파일 에러! String 타입인데 Int 대입
prefs[WidgetKeys.SETTINGS] = "enabled" // ✅ 이제 String만 가능
```

**장점**:
- 키 정의만 변경하면 컴파일러가 모든 사용처를 체크
- 수정이 필요한 곳을 IDE가 모두 표시
- 런타임 크래시 없이 안전하게 타입 변경 가능

---

### 해결책 4: IDE 자동완성 완벽 지원

```kotlin
val prefs = currentState<Preferences>()

// 1. 키 입력 시 자동완성
val value = prefs[WidgetKeys. // IDE가 모든 키 목록 표시
    // COUNT
    // NAME
    // IS_ENABLED
    // LAST_UPDATE
    // TEMPERATURE
]

// 2. 타입 힌트 제공
val count = prefs[WidgetKeys.COUNT] // count: Int?로 표시됨
val name = prefs[WidgetKeys.NAME] // name: String?로 표시됨
```

**장점**:
- 키 이름을 외울 필요 없음
- 타이핑 속도 향상
- 실수 방지

---

### 해결책 5: 리팩토링 안전성

```kotlin
// 키 이름 변경이 필요하면
object WidgetKeys {
    val USER_COUNT = intPreferencesKey("count") // 변수명 변경
}

// IntelliJ Refactor > Rename 사용
// → 모든 사용처가 자동으로 변경됨
prefs[WidgetKeys.USER_COUNT] = 10 // ✅ 자동 변경
val count = prefs[WidgetKeys.USER_COUNT] ?: 0 // ✅ 자동 변경

// 놓치는 곳이 없음!
```

**장점**:
- IDE의 Refactor 기능 완벽 지원
- 모든 사용처가 자동으로 변경됨
- 누락 걱정 없음

---

### 해결책 6: 기본값 타입 일치 강제

```kotlin
val countKey = intPreferencesKey("count")

// 읽을 때 기본값도 같은 타입이어야 함
val count1 = prefs[countKey] ?: 0 // ✅ Int 기본값
val count2 = prefs[countKey] ?: 0L // ❌ 컴파일 경고 (Long은 권장하지 않음)
val count3 = prefs[countKey] ?: "0" // ❌ 컴파일 에러! Type mismatch
```

**장점**:
- 엘비스 연산자의 타입이 자동으로 추론됨
- 잘못된 타입의 기본값 사용 시 컴파일 에러
- 런타임 크래시 원천 차단

---

## 3. 타입별 Preferences Key

Glance DataStore는 다양한 타입의 Key를 제공합니다:

```kotlin
// Preferences DataStore가 지원하는 모든 타입
val intKey = intPreferencesKey("int_value")           // Int
val longKey = longPreferencesKey("long_value")        // Long
val doubleKey = doublePreferencesKey("double_value")  // Double
val floatKey = floatPreferencesKey("float_value")     // Float
val booleanKey = booleanPreferencesKey("bool_value")  // Boolean
val stringKey = stringPreferencesKey("string_value")  // String
val stringSetKey = stringSetPreferencesKey("set")     // Set<String>

// 각 키는 정확히 해당 타입만 허용
updateAppWidgetState(context, glanceId) { prefs ->
    prefs[intKey] = 42               // ✅
    prefs[intKey] = 42L              // ❌ 컴파일 에러

    prefs[booleanKey] = true         // ✅
    prefs[booleanKey] = 1            // ❌ 컴파일 에러

    prefs[stringKey] = "text"        // ✅
    prefs[stringKey] = 123           // ❌ 컴파일 에러

    prefs[stringSetKey] = setOf("a") // ✅
    prefs[stringSetKey] = listOf("a") // ❌ 컴파일 에러
}
```

---

## 4. 실전 예제: 타입 안정성이 버그를 방지하는 경우

**시나리오**: 위젯에 카운터와 상태 메시지를 표시. 두 명의 개발자가 협업.

### ❌ 전통 위젯 - 타입 불안정으로 인한 크래시

```kotlin
class BadWidgetReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val prefs = context.getSharedPreferences("widget", Context.MODE_PRIVATE)

        // 개발자 A: 카운터 증가 기능 구현
        val count = prefs.getInt("value", 0)
        prefs.edit().putInt("value", count + 1).apply()

        // 개발자 B: 며칠 후 에러 상태 저장 기능 추가
        // 실수로 같은 "value" 키를 String으로 사용
        prefs.edit().putString("value", "error").apply()

        // 다시 카운터를 읽으려고 하면?
        val newCount = prefs.getInt("value", 0) // ❌ 크래시!
        // java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
    }
}
```

**문제 분석**:
1. 개발자 A와 B가 같은 키 "value"를 다른 타입으로 사용
2. 컴파일 타임에는 아무런 경고 없음
3. 런타임에 ClassCastException으로 앱 크래시
4. 디버깅이 어려움 (키 이름만으로는 문제 파악 어려움)

---

### ✅ Glance 위젯 - 타입 안정으로 컴파일 타임 방지

```kotlin
// 키 정의를 중앙에서 관리
object WidgetKeys {
    val COUNT = intPreferencesKey("count")
    val STATUS = stringPreferencesKey("status")
}

class GoodAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        updateAppWidgetState(context, glanceId) { prefs ->
            // 개발자 A: 카운터 증가
            val count = prefs[WidgetKeys.COUNT] ?: 0
            prefs[WidgetKeys.COUNT] = count + 1

            // 개발자 B: 실수로 같은 키를 사용하려고 해도
            prefs[WidgetKeys.COUNT] = "error" // ❌ 컴파일 에러!
            // Type mismatch: inferred type is String but Int was expected

            // IDE가 빨간 밑줄로 표시하고 코드 작성 단계에서 발견됨!

            // 올바른 방법은 다른 키 사용
            prefs[WidgetKeys.STATUS] = "error" // ✅
        }
    }
}
```

**해결 분석**:
1. 각 키가 명확한 타입을 가짐 (COUNT는 Int, STATUS는 String)
2. 타입 불일치 시도 시 즉시 컴파일 에러
3. IDE가 빨간 밑줄로 표시 + 에러 메시지 표시
4. 코드 작성 단계에서 즉시 수정 가능
5. 런타임 크래시 원천 차단

---

## 5. 타입 안정성의 핵심 가치

> [!NOTE]
> "**타입 안정성의 핵심 가치**는 **버그를 런타임에서 컴파일 타임으로 옮긴다**는 점입니다.
>
> **전통 위젯 (SharedPreferences)**:
> - 문자열 키 → 오타 가능 → 컴파일러가 못 잡음 → 런타임에 0이나 null 반환 → 버그
> - 타입 불일치 → 컴파일러가 못 잡음 → 런타임에 ClassCastException → 크래시
> - 리팩토링 위험 → 수동 검색 → 놓치면 버그
>
> **Glance DataStore (Typed Key)**:
> - `intPreferencesKey("count")` → 타입이 Int로 고정
> - 다른 타입 대입 시 → 컴파일 에러 → 코드 작성 단계에서 발견
> - IDE 자동완성 → 오타 방지
> - Refactor > Rename → 모든 사용처 자동 변경 → 안전
>
> **결론**: Glance의 Typed Key는 **컴파일러와 IDE의 도움**을 받아 타입 관련 버그를 **근본적으로 예방**합니다. 이는 특히 여러 개발자가 협업하거나 장기간 유지보수하는 프로젝트에서 엄청난 가치를 발휘합니다."

**[스크린샷 추천]** IDE에서 타입 불일치 컴파일 에러가 빨간 밑줄로 표시되는 화면

---

## 6. 비교 요약표

| 측면         | 전통 위젯 (SharedPreferences)  | Glance 위젯 (DataStore)        |
| ---------- | -------------------------- | ---------------------------- |
| **키 타입**   | String (타입 없음)             | `Preferences.Key<T>` (타입 있음) |
| **타입 체크**  | 런타임                        | 컴파일 타임                       |
| **오타 감지**  | ❌ 불가능 (0/null 반환)          | ✅ 가능 (컴파일 에러)                |
| **타입 불일치** | ❌ ClassCastException (크래시) | ✅ 컴파일 에러 (사전 방지)             |
| **자동완성**   | ❌ 없음                       | ✅ 완벽 지원                      |
| **리팩토링**   | ❌ 수동 검색 필요                 | ✅ IDE Refactor 가능            |
| **기본값 타입** | ⚠️ 일치 여부 확인 불가             | ✅ 타입 강제 일치                   |
| **타입 변경**  | ❌ 위험 (런타임 크래시)             | ✅ 안전 (컴파일 에러)                |
| **협업 안전성** | ❌ 낮음 (문자열 충돌)              | ✅ 높음 (컴파일 보장)                |

---

## 7. 베스트 프랙티스

### ✅ DO
- **키를 중앙에서 관리**: `object WidgetKeys`로 모든 키를 한 곳에 정의
- **명확한 키 이름**: `COUNT`, `USER_NAME` 같이 용도가 명확한 이름 사용
- **타입에 맞는 Key 함수 사용**: Int는 `intPreferencesKey`, String은 `stringPreferencesKey`
- **엘비스 연산자로 기본값 제공**: `prefs[key] ?: defaultValue`

### ❌ DON'T
- **인라인 문자열 키 사용 금지**: `intPreferencesKey("count")` 대신 상수로 정의
- **같은 키 이름 재사용 금지**: 각 키는 고유한 목적을 가져야 함
- **타입 변경 시 키 이름도 변경**: 마이그레이션 명확성을 위해

---

## 8. 관련 문서

- **[10. State 관리⭐⭐](10.%20State%20관리⭐⭐.md)** - State 관리 기본 개념
- **[4. 의존성 추가⭐](4.%20의존성%20추가⭐.md)** - DataStore 의존성 설정
- **[11. 성능 최적화 & 베스트 프랙티스⭐](11.%20성능%20최적화%20&%20베스트%20프랙티스⭐.md)** - 상태 관리 안티패턴
