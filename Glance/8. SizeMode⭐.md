> [!TIP] 🗣️ 핵심내용
다양한 화면 크기에 대응하는 위젯 레이아웃 전략을 설정합니다. Single, Exact, Responsive 모드를 알아봅니다.
>

## 1. SizeMode 개요

SizeMode는 위젯 콘텐츠를 **어떤 '레이아웃 버킷'**(작은/큰 레이아웃 등)으로 렌더링할지 **결정하는 힌트**입니다. 즉, 어떤 UI 구성을 택할지를 정하는 **브레이크포인트** 개념입니다.

```
📏 SizeMode의 역할
위젯 → 브레이크포인트 정의 → Glance가 버킷 선택 → UI 렌더링
런처 → 그리드/셀 규칙 적용 → 실제 바운딩 박스 크기(dp) 결정
```

### 1.1 핵심 개념

**버킷(Bucket)**
- SizeMode가 선택하는 "레이아웃 구간"
- 실제 위젯 크기(dp)를 런처가 정하면, Glance가 미리 정의한 브레이크포인트 집합 중 하나를 골라 해당 구간(버킷)의 레이아웃으로 렌더링

**런처의 역할**
- 홈 그리드/셀 규칙과 인셋을 기반으로 실제 위젯 박스 크기(dp) 산출
- 리사이즈 상한/하한은 앱이 아니라 런처 권한에 있음
- 기기/런처마다 "셀 크기 × 차지하는 칸 수 – 런처 패딩/인셋" 방식으로 계산

---

## 2. SizeMode 종류

### 2.1 Single
크기 구분 없이 한 가지 레이아웃만 사용합니다.

```kotlin
class SimpleWidget : GlanceAppWidget() {
    override val sizeMode = SizeMode.Single

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // 크기에 관계없이 동일한 레이아웃
            Column(
                modifier = GlanceModifier.fillMaxSize().padding(16.dp)
            ) {
                Text("Simple Widget")
                Text("One size fits all")
            }
        }
    }
}
```

**특징**
- ✅ 가장 단순하고 성능이 좋음
- ✅ LocalSize.current가 변하지 않음
- ❌ 다양한 크기에 유연하게 대응 불가

---

### 2.2 Exact
**정확한 위젯 크기 값을 그대로 제공**합니다.

```kotlin
class ExactSizeWidget : GlanceAppWidget() {
    override val sizeMode = SizeMode.Exact

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val size = LocalSize.current  // 1픽셀 단위로 변화 감지!

            // 크기 변경 시마다 즉시 재생성 발생
            val backgroundColor = when {
                size.width < 150.dp -> Color.Red      // 149dp까지
                size.width < 200.dp -> Color.Blue     // 150-199dp
                size.width < 250.dp -> Color.Green    // 200-249dp
                else -> Color.Yellow                  // 250dp 이상
            }

            Box(
                modifier = GlanceModifier
                    .fillMaxSize()
                    .background(backgroundColor),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "${size.width.value.toInt()}dp × ${size.height.value.toInt()}dp",
                    style = TextStyle(color = ColorProvider(Color.White))
                )
            }
        }
    }
}
```

**특징**
- ✅ 모든 크기에 세밀하게 대응 가능
- ✅ 유연한 레이아웃 로직 구현
- ❌ 크기 변경 시마다 재생성 발생 (성능 저하)
- ❌ 모든 크기에 대응하는 레이아웃 로직을 직접 작성해야 함

**[비디오 추천]** Exact 모드에서 위젯 리사이즈 시 픽셀 단위로 배경색이 변하는 모습

---

### 2.3 Responsive
미리 정의한 여러 사이즈 버킷(DpSize 집합) 중에서 런타임 크기와 가장 가까운 것을 선택합니다.

```kotlin
class ResponsiveWidget : GlanceAppWidget() {
    override val sizeMode = SizeMode.Responsive(
        setOf(
            DpSize(180.dp, 80.dp),   // "이 정도 크기면 작은 UI를 보여주세요"
            DpSize(250.dp, 120.dp),  // "이 정도면 중간 UI를 보여주세요"
            DpSize(320.dp, 180.dp)   // "이 정도면 큰 UI를 보여주세요"
        )
    )

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val size = LocalSize.current
            when {
                size.width < 220.dp -> CompactUI()
                size.width < 280.dp -> MediumUI()
                else -> LargeUI()
            }
        }
    }
}

@Composable
fun CompactUI() {
    Column(modifier = GlanceModifier.fillMaxSize().padding(8.dp)) {
        Text("Compact", style = TextStyle(fontSize = 14.sp))
    }
}

@Composable
fun MediumUI() {
    Column(modifier = GlanceModifier.fillMaxSize().padding(12.dp)) {
        Text("Medium", style = TextStyle(fontSize = 16.sp))
        Text("More details here")
    }
}

@Composable
fun LargeUI() {
    Column(modifier = GlanceModifier.fillMaxSize().padding(16.dp)) {
        Text("Large", style = TextStyle(fontSize = 18.sp, fontWeight = FontWeight.Bold))
        Text("More details here")
        Button("Action", onClick = actionRunCallback<MyAction>())
    }
}
```

> [!NOTE] 
> "**Responsive 모드**가 가장 권장되는 방식입니다. 동작 원리를 이해하는 게 중요해요.
>
> **미리 렌더링**: Responsive는 정의한 3개 크기(180dp, 250dp, 320dp)에 대해 각각 RemoteViews를 **미리 만들어서** 시스템에 등록합니다. 마치 '작은 버전', '중간 버전', '큰 버전' 3가지를 준비해두는 거죠.
>
> **런타임 선택**: 사용자가 위젯 크기를 조절하면, 시스템이 현재 크기와 가장 가까운 버킷을 선택해서 보여줍니다. 예를 들어 실제 크기가 230dp면 250dp 버킷을 선택하고, 그에 해당하는 RemoteViews를 표시합니다.
>
> **성능 최적화**: 크기가 조금씩 바뀔 때마다 다시 렌더링하지 않습니다. 정의된 브레이크포인트를 넘어설 때만 다른 버전으로 교체하죠. 그래서 Exact보다 훨씬 효율적입니다.
>
> **LocalSize.current**: `provideContent` 안에서 `LocalSize.current`로 실제 크기를 알 수 있습니다. 이걸 보고 when 분기로 다른 UI를 보여주면 됩니다.
>
> **주의**: Android 12 미만에서는 Responsive가 제대로 작동 안 하고 Exact처럼 동작합니다. 그래서 minSdk를 31(Android 12)로 올리는 게 좋습니다."

**특징**
- ✅ 성능과 유연성의 균형
- ✅ 정의된 브레이크포인트에서만 재생성
- ⚠️ Android 12+ (12 미만에서는 사실상 Exact처럼 동작)
	-  "버킷 무시되고 매번 provideGlance 재호출"
- ⚠️ SizeMode.Responsive에 정의한 크기들은 **절대적인 규칙이 아니라 시스템에 대한 "힌트"**

**사용 시 주의사항**
- 런처가 위젯을 배치할 때 **가장 적절한 크기**를 자동 선택
- 사용자가 위젯 크기를 조절할 때 이 크기들을 **참고**하지만 반드시 따르지는 않음

**[비디오 추천]** Responsive 모드에서 위젯 리사이즈 시 버킷별로 레이아웃이 전환되는 모습

---

## 3. SizeMode별 성능 비교

| SizeMode       | LocalSize 변화 | 크기 제약   | 성능    | 권장 용도       |
| -------------- | ------------ | ------- | ----- | ----------- |
| **Single**     | ❌ 변하지 않음     | XML 설정만 | 🟢 최고 | 고정 레이아웃 위젯  |
| **Responsive** | ✅ 정의된 크기로    | 개발자 정의  | 🟡 균형 | 반응형 위젯 (권장) |
| **Exact**      | ✅ 모든 픽셀      | 제약 없음   | 🔴 낮음 | 고도화된 위젯     |

---

## 4. 실전 예시: 2단계 크기 위젯

### 4.1 테스트 환경
- **기종**: Galaxy Z Flip 4
- **화면 크기**: 360dp × 880dp
- **홈 화면 배열**: 4 × 5
- **한 칸 크기**: 84dp × 124dp
- **위젯 영역(3칸 × 5칸 점유)**: 335dp × 618dp

**[스크린샷 추천]** 홈 화면 그리드와 위젯 영역 표시

---

### 4.2 구현 코드

```kotlin
class TwoSizeWidget : GlanceAppWidget() {
    override val sizeMode = SizeMode.Responsive(
        setOf(
            DpSize(180.dp, 74.dp),   // 작은 크기
            DpSize(320.dp, 180.dp)   // 큰 크기 (중간 크기 생략)
        )
    )

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val size = LocalSize.current

            if (size.width < 250.dp) {
                SmallLayout()
            } else {
                LargeLayout()
            }
        }
    }
}
```

```xml
<!-- res/xml/widget_info.xml -->
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/placeholder"
    android:maxResizeWidth="320dp"
    android:maxResizeHeight="400dp"
    android:minWidth="180dp"
    android:minHeight="74dp"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen" />
```

---

### 4.3 버킷 선택 규칙

**TwoSizeWidget의 브레이크포인트**
- 작은 버킷: 180dp × 74dp
- 큰 버킷: 320dp × 180dp

**선택 규칙**
- 런처상의 박스 크기(W, H) 이상을 요구하지 않는(둘 다 <=) 버킷 중 **가장 큰 것**을 선택
- 그런 버킷이 없으면 가장 작은 것을 선택
- 버킷의 크기 + 위젯 XML info의 최소/최대값도 고려

**이 그리드에서의 버킷 전환 임계치(칸 수로 환산)**
- 180dp 너비: ceil(180 / 84) = 3칸 → 252dp
- 74dp 높이: ceil(74 / 124) = 1칸 → 124dp
- 320dp 너비: ceil(320 / 84) = 4칸 → 336dp
- 180dp 높이: ceil(180 / 124) = 2칸 → 248dp

**실제 테스트 결과**
- 높이 74dp까지는 1칸
- 높이 75dp부터는 2칸이 됨
- 런처마다 미세한 차이가 있을 수 있음

**[스크린샷 추천]** 런처에서 위젯 선택 시 최소 브레이크포인트가 적용된 모습

---

## 5. 런처별 차이점

SizeMode.Responsive에 정의한 크기들은 **시스템에 대한 힌트**일 뿐, 런처가 반드시 따르는 것은 아닙니다.
- “특정 OEM 런처에서 Responsive를 무시한다면, 해당 환경에서는 결국 Exact처럼 빈번히 업데이트가 일어날 수 있으므로, **크기 대응 로직을 보완하거나 최적화를 고려**해야 합니다”
### 5.1 런처별 구현 차이
- **삼성 런처**: 비교적 정확히 따름
- **구글 런처**: 근사치로 조정
- **기타 런처**: 완전히 무시하고 자체 로직 사용

### 5.2 시스템의 해석
> "개발자가 이런 크기들을 염두에 두고 UI를 설계했구나"
> "가능하면 이 크기들 근처에서 조정해보자"
> "하지만 우리(런처)의 제약사항이 더 우선이야"

### 5.3 영향 요인
1. **화면 밀도와 해상도**
   - 다른 DPI 디바이스에서 픽셀-dp 변환 시 미세한 차이
   - 화면 크기에 따른 자동 조정

2. **런처별 구현 차이**
   - 각 런처가 자체 그리드 시스템 사용
   - 패딩, 인셋 계산 방식이 다름

---

## 6. 권장 전략

### 6.1 일반적인 위젯
```kotlin
override val sizeMode = SizeMode.Responsive(
    setOf(
        DpSize(100.dp, 100.dp),   // 작음
        DpSize(200.dp, 100.dp),   // 중간
        DpSize(300.dp, 200.dp)    // 큼
    )
)
```

### 6.2 고정 크기 위젯
```kotlin
override val sizeMode = SizeMode.Single
```

### 6.3 고도화된 위젯
```kotlin
override val sizeMode = SizeMode.Exact

provideContent {
    val size = LocalSize.current
    // 모든 크기에 대응하는 복잡한 로직
}
```

---