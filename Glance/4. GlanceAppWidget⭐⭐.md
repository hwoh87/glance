> [!TIP] 🗣️ 핵심내용
실제 위젯의 UI와 동작을 정의하는 핵심 클래스입니다. `provideGlance()` 함수에서 위젯 컨텐츠를 구성합니다.
>

## 1. GlanceAppWidget이란?

`GlanceAppWidget`은 기존 홈 화면 위젯(`AppWidget`)을 **Compose스러운 DSL**로 작성할 수 있게 해주는 Jetpack 라이브러리의 핵심 베이스 클래스입니다.

### 1.1 핵심 개념
- 위젯 개발의 **진입점**
- 화면에는 Compose가 직접 그려지는 게 아니라, Glance DSL → **`RemoteViews`**로 변환되어 **`AppWidget`** 시스템 위에서 동작
- **목적**: `RemoteViews`의 제약(호환성/표현력/개발 편의)을 완화하고, 선언적 DSL로 **간결하고 안전**하게 위젯을 작성

---

## 2. 기본 템플릿

```kotlin
class MyWidget : GlanceAppWidget() {
    // 1. 상태 저장 방식 정의
    override val stateDefinition = PreferencesGlanceStateDefinition

    // 2. 크기 대응 전략 정의
    override val sizeMode = SizeMode.Responsive(
        setOf(
            DpSize(180.dp, 110.dp),
            DpSize(250.dp, 150.dp)
        )
    )

    // 3. UI 제공 메서드
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            WidgetContent()
        }
    }

    // 4. 실제 UI 구성
    @Composable
    private fun WidgetContent() {
        val prefs = currentState<Preferences>()
        val count = prefs[intPreferencesKey("count")] ?: 0

        Column(
            modifier = GlanceModifier.fillMaxSize().padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Count: $count",
                style = TextStyle(fontSize = 20.sp, fontWeight = FontWeight.Bold)
            )
            Button(
                text = "Increment",
                onClick = actionRunCallback<IncrementAction>()
            )
        }
    }
}
```

> [!NOTE] 💬 발표 설명
> "기본 템플릿을 보면 GlanceAppWidget의 구조가 명확합니다.
>
> 1. **stateDefinition**: 위젯 상태를 어떻게 저장할지 정합니다. PreferencesGlanceStateDefinition이 가장 간단하고 많이 씁니다.
>
> 2. **sizeMode**: 위젯 크기가 변경될 때 어떻게 대응할지 정합니다. Responsive가 권장 방식입니다.
>
> 3. **provideGlance()**: 위젯이 업데이트될 때마다 호출됩니다. 여기서 `provideContent` 블록으로 UI를 제공하죠.
>
> 4. **WidgetContent()**: 실제 UI를 Compose 스타일로 작성합니다. `currentState()`로 상태를 읽고, Column/Text/Button 같은 컴포넌트로 화면을 구성합니다.
>
> 핵심은 **provideGlance()가 호출되는 시점**을 이해하는 겁니다. 위젯 추가, 업데이트, 크기 변경, 상태 변경 후 update() 호출 등 여러 상황에서 호출됩니다."

---

## 3. 핵심 구성 요소

### 3.1 `stateDefinition`
위젯 상태 저장 방식을 정의합니다.

```kotlin
// Preferences 기반 (간단한 key-value) - 가장 일반적
override val stateDefinition = PreferencesGlanceStateDefinition
```

**상태 관리에 대한 자세한 내용은 → [10. State 관리⭐](10.%20State%20관리⭐.md)** 참고

---

### 3.2 `sizeMode`
위젯이 다양한 크기에서 어떻게 동작할지 정의합니다.

```kotlin
// 반응형 (권장)
override val sizeMode = SizeMode.Responsive(
    setOf(
        DpSize(180.dp, 110.dp),
        DpSize(250.dp, 150.dp)
    )
)
```

**SizeMode에 대한 자세한 내용은 → [7. SizeMode](7.%20SizeMode.md)** 참고

---

### 3.3 `provideGlance()`
시스템이 '위젯을 그려라' 하고 호출할 때 실행되는 메서드입니다.

```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    // ⚠️ 주의: provideContent 외부에서 가벼운 준비 작업만
    // 무거운 I/O는 Worker로 분리 필요

    provideContent {
        // ✅ DataStore에서 상태 읽기만
        val prefs = currentState<Preferences>()
        val data = prefs[dataKey] ?: "기본값"

        WidgetUI(data)
    }
}
```

**특징**
- `suspend` 함수로 정의되지만 **무거운 I/O는 금지**
- `context`: Android Context
- `id`: 위젯 인스턴스를 구분하는 고유 ID (`GlanceId`)

---

### 3.4 `provideContent {}` - UI 선언 전용 구간

#### 3.4.1 기본 사용법

Glance DSL로 UI를 작성하는 블록입니다. **RemoteViews로 변환될 UI 트리만 선언**하는 단계입니다.

```kotlin
provideContent {
    // Glance Composable 사용
    Column {
        Text("Hello")
        Button("Click", onClick = { /* ... */ })
    }
}
```

#### 3.4.2 ⚠️ 중요: provideContent에서 네트워크 호출 금지

> [!WARNING] 왜 provideContent에서 네트워크/I/O를 하면 안 되나요?
>
> **1. RemoteViews 변환 구간의 특성**
> - `provideContent`는 **"RemoteViews로 변환될 UI 트리만 선언"**하는 단계입니다.
> - Compose 런타임 기능(`remember`, `LaunchedEffect`, 코루틴 컨텍스트)이 동작하지 않습니다.
> - UI 선언 중에 블로킹/I/O가 끼면 **렌더링 실패 또는 지연**이 발생합니다.
>
> **2. 프로세스 제약**
> - 위젯은 **런처 프로세스와 IPC로 그려지는** 별도 프로세스/스레드 환경입니다.
> - 이 환경에서 네트워크/DB 호출은 **안정적이지 않고**, ANR(Application Not Responding) 위험이 있습니다.
>
> **3. 올바른 패턴**
> ```kotlin
> ❌ 잘못된 예 - provideContent 내부에서 네트워크 호출
> provideContent {
>     val data = runBlocking { fetchDataFromNetwork() } // ❌ ANR 위험!
>     Text(data)
> }
>
> ✅ 올바른 예 - Worker에서 준비 → DataStore 저장 → UI는 읽기만
> // 1. Worker에서 데이터 가져오기
> class DataUpdateWorker : CoroutineWorker(...) {
>     override suspend fun doWork(): Result {
>         val data = repository.fetchData() // 네트워크 호출
>
>         // DataStore에 저장
>         updateAppWidgetState(context, glanceId) { prefs ->
>             prefs[dataKey] = data
>         }
>
>         // UI 갱신 트리거
>         MyWidget().update(context, glanceId)
>         return Result.success()
>     }
> }
>
> // 2. UI는 currentState()로 읽기만
> provideContent {
>     val prefs = currentState<Preferences>()
>     val data = prefs[dataKey] ?: "로딩 중..."
>     Text(data)
> }
> ```
>
> **정리**: 데이터는 Worker/Repository에서 준비 → DataStore에 저장 → UI는 `currentState()`로 읽기만.

#### 3.4.3 최초 로딩 UX 권장 패턴

위젯이 처음 추가되었을 때 데이터가 없는 상태를 처리하는 패턴입니다.

```kotlin
@Composable
fun WidgetContent() {
    val prefs = currentState<Preferences>()
    val data = prefs[stringPreferencesKey("weather_data")]
    val isLoading = prefs[booleanPreferencesKey("is_loading")] ?: false
    val errorMsg = prefs[stringPreferencesKey("error_message")]

    Column(
        modifier = GlanceModifier.fillMaxSize().padding(16.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        when {
            // 1. 에러 상태: 재시도 버튼 제공
            errorMsg != null -> {
                Text("⚠️ $errorMsg", style = TextStyle(color = Color.Red))
                Spacer(GlanceModifier.height(8.dp))
                Button(
                    text = "새로고침",
                    onClick = actionRunCallback<RefreshDataAction>()
                )
            }

            // 2. 로딩 중: 스켈레톤/플레이스홀더
            isLoading -> {
                CircularProgressIndicator()
                Text("로딩 중...", style = TextStyle(color = Color.Gray))
            }

            // 3. 데이터 없음: 초기 상태
            data == null -> {
                Text("📊 데이터를 불러오려면\n아래 버튼을 눌러주세요")
                Spacer(GlanceModifier.height(8.dp))
                Button(
                    text = "데이터 불러오기",
                    onClick = actionRunCallback<LoadInitialDataAction>()
                )
            }

            // 4. 정상 데이터 표시
            else -> {
                Text(data)
                Button(
                    text = "새로고침",
                    onClick = actionRunCallback<RefreshDataAction>()
                )
            }
        }
    }
}

// ActionCallback: Worker로 백그라운드 작업 위임
class LoadInitialDataAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 즉시 로딩 상태 표시
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[booleanPreferencesKey("is_loading")] = true
        }
        MyWidget().update(context, glanceId)

        // Worker로 실제 데이터 로드 작업 위임
        val workRequest = OneTimeWorkRequestBuilder<DataFetchWorker>()
            .setInputData(workDataOf("glance_id" to glanceId.toString()))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)
    }
}
```

**[스크린샷 추천]** 위젯 로딩 → 데이터 표시 → 에러 → 재시도 흐름

> [!NOTE] 💬 발표 설명
> "**최초 로딩 UX는 4가지 상태**를 처리해야 합니다.
>
> 1. **에러 상태**: 네트워크 오류 등의 메시지와 '새로고침' 버튼
> 2. **로딩 중**: 로딩 인디케이터나 '로딩 중...' 텍스트
> 3. **초기 상태**: 데이터가 없을 때 '데이터 불러오기' 버튼
> 4. **정상 상태**: 실제 데이터 표시
>
> **핵심 패턴**:
> - ActionCallback에서 즉시 로딩 상태로 변경 → `update()` 호출 (사용자에게 피드백)
> - Worker를 enqueue해서 백그라운드 작업 위임
> - Worker가 완료되면 DataStore 업데이트 → `update()` 호출 (결과 반영)
>
> 이렇게 하면 **UI는 절대 블로킹되지 않고**, 사용자는 로딩 상태를 명확히 인지할 수 있습니다."

**Worker 구현 예시**:
```kotlin
class DataFetchWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        val glanceIdString = inputData.getString("glance_id") ?: return Result.failure()
        val glanceId = GlanceId(glanceIdString)

        return try {
            // 네트워크/DB에서 데이터 가져오기 (무거운 I/O)
            val data = repository.fetchWeatherData()

            // DataStore에 저장
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                prefs[stringPreferencesKey("weather_data")] = data
                prefs[booleanPreferencesKey("is_loading")] = false
                prefs.remove(stringPreferencesKey("error_message"))
            }

            // UI 갱신
            MyWidget().update(applicationContext, glanceId)
            Result.success()

        } catch (e: Exception) {
            // 에러 상태 저장
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                prefs[booleanPreferencesKey("is_loading")] = false
                prefs[stringPreferencesKey("error_message")] = e.message ?: "알 수 없는 오류"
            }
            MyWidget().update(applicationContext, glanceId)
            Result.failure()
        }
    }
}
```

**Worker 관련 자세한 내용은 → [5. Glance 생명주기 & 업데이트 트리거⭐](5.%20Glance%20생명주기%20&%20업데이트%20트리거⭐.md)** 참고

---

## 4. UI 작성 규칙

### 4.1 사용 가능한 컴포넌트

**레이아웃**
- `Column`: 세로 배치
- `Row`: 가로 배치
- `Box`: 겹쳐서 배치
- `Spacer`: 빈 공간
- `LazyColumn`: 스크롤 가능한 리스트 (제한적)

**UI 요소**
- `Text`: 텍스트
- `Image`: 이미지
- `Button`: 버튼
- `CheckBox`: 체크박스
- `Switch`: 스위치
- `RadioButton`: 라디오 버튼

**UI 작성 규칙에 대한 자세한 내용은 → [6. UI 작성 규칙 및 제약사항⭐](6.%20UI%20작성%20규칙%20및%20제약사항⭐.md)** 참고

---

### 4.2 단위 사용

Glance에서는 **`androidx.glance.unit.dp`**를 사용합니다 (Compose의 `dp`와 다름).

```kotlin
import androidx.glance.unit.dp  // ✅ Glance의 dp

// ❌ 잘못된 예
import androidx.compose.ui.unit.dp  // Compose의 dp (Glance에서 사용 불가)
```

---

### 4.3 상태 접근

`currentState<T>()`로 현재 위젯의 상태를 읽습니다.

```kotlin
@Composable
fun WidgetContent() {
    val prefs = currentState<Preferences>()
    val count = prefs[intPreferencesKey("count")] ?: 0

    Text("Count: $count")
}
```

---

## 5. RemoteViews 제약 (Compose와 다름)

Glance는 `RemoteViews` 기반이므로 다음과 같은 제약이 있습니다:

- ❌ `remember`, `LaunchedEffect` 등 Compose 런타임 API 사용 불가
- ❌ 애니메이션 제한
- ❌ Coil/Glide 직접 사용 불가

```kotlin
// ❌ 사용 불가
var count by remember { mutableStateOf(0) }

// ✅ 대신 StateDefinition 사용
val prefs = currentState<Preferences>()
val count = prefs[intPreferencesKey("count")] ?: 0
```

**RemoteViews 제약에 대한 자세한 내용은 → [6. UI 작성 규칙 및 제약사항⭐](6.%20UI%20작성%20규칙%20및%20제약사항⭐.md)** 참고

---

## 6. 실전 예제 참고

GlanceAppWidget의 실전 활용 예제는 다음 챕터에서 자세히 다룹니다:

- **날씨 위젯** (상태 관리, 크기 대응, 사용자 인터랙션 종합): **[10. State 관리⭐⭐](10.%20State%20관리⭐⭐.md)** 섹션 8 참고
- **Todo 위젯** (복잡한 상태, 리스트 관리, 다중 액션): **[8. Action(이벤트) 처리 방식⭐⭐](8.%20Action(이벤트)%20처리%20방식⭐⭐.md)** 섹션 6 참고

이 예제들은 `GlanceAppWidget`의 모든 핵심 요소를 종합적으로 보여줍니다:
- `stateDefinition`: 위젯 상태 저장 방식
- `sizeMode`: 반응형 크기 대응
- `provideGlance()`: UI 제공 및 데이터 로드
- `currentState()`: 상태 읽기 및 UI 반영
- `ActionCallback`: 사용자 인터랙션 처리

---

## 7. initialLayout 플레이스홀더 (필수 설정)

위젯을 추가할 때 Glance가 실제 UI를 렌더링하기 전까지 **임시로 보여줄 레이아웃**을 설정해야 합니다.

### 7.1 플레이스홀더 설정

```xml
<!-- res/xml/widget_info.xml -->
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_placeholder"  <!-- 필수! -->
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:previewImage="@drawable/widget_preview"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen" />
```

```xml
<!-- res/layout/widget_placeholder.xml -->
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:text="Loading..."
    android:gravity="center"
    android:textColor="#666666"
    android:background="#FFFFFF" />
```

> [!NOTE] 💬 발표 설명
> "`initialLayout`은 **필수 설정**입니다. 이 리소스가 없으면 위젯이 위젯 선택 화면에 아예 안 나타날 수 있어요.
>
> 사용자가 위젯을 추가하는 순간, Glance가 `provideGlance()`를 실행해서 실제 UI를 만들기 전까지 잠깐 보여줄 임시 화면입니다. 'Loading...' 같은 단순한 텍스트나 로고 정도면 충분합니다.
>
> 실제로는 몇 밀리초~1초 정도만 보이지만, 이 파일 자체가 없으면 시스템이 위젯을 인식하지 못합니다."

### 7.2 주의사항

- ✅ **반드시 생성**: XML 레이아웃 파일이 실제로 존재해야 함
- ✅ **단순하게**: TextView 하나 정도로 충분
- ✅ **빠른 로딩**: 무거운 레이아웃 피하기
- ⚠️ **미노출 위험**: 없으면 위젯 목록에 안 뜰 수 있음

---

## 8. Glance 동작 원리

### 8.1 렌더링 흐름

```
📱 사용자가 위젯 추가
   ↓
📑 initialLayout 즉시 표시 (플레이스홀더)
   ↓
📡 GlanceAppWidgetReceiver 호출
   ↓
🧩 provideGlance() 실행
   ↓
🎨 provideContent { } - Glance DSL 작성
   ↓
🔄 Glance 엔진이 자동으로 RemoteViews 변환
   ↓
✅ 실제 위젯 UI 표시
```

### 8.2 핵심 포인트

- **선언형 UI**: 개발자는 DSL만 작성
- **자동 변환**: Glance가 RemoteViews로 변환
- **RemoteViews 기반**: 따라서 제약사항 존재 (→ [6. UI 작성 규칙](4.세미나/Glance/6.%20UI%20작성%20규칙%20및%20제약사항⭐⭐.md) 참고)

---

## 9. 체크리스트

- [ ] `GlanceAppWidget` 상속한 클래스 작성
- [ ] `stateDefinition` 정의 (Preferences 또는 Proto)
- [ ] `sizeMode` 정의 (대부분 Responsive 권장)
- [ ] `provideGlance()` 구현
- [ ] `provideContent {}` 내부에 Glance Composable 작성
- [ ] **`initialLayout` XML 파일 생성** (필수!)
- [ ] Glance의 `dp` 사용 확인 (`androidx.glance.unit.dp`)
- [ ] Compose 런타임 API 사용하지 않았는지 확인
- [ ] `currentState<T>()`로 상태 접근

---

---
