> [!TIP] 🗣️ 핵심내용
실제 위젯의 UI와 동작을 정의하는 핵심 클래스입니다. `provideGlance()` 함수에서 위젯 컨텐츠를 구성합니다.
>

## 1. GlanceAppWidget이란?

`GlanceAppWidget`은 기존 홈 화면 위젯(`AppWidget`)을 **Compose스러운 DSL**로 작성할 수 있게 해주는 Jetpack 라이브러리의 핵심 베이스 클래스입니다.

### 1.1 핵심 개념
- 위젯 개발의 **진입점**
- 화면에는 Compose가 직접 그려지는 게 아니라, Glance DSL → **`RemoteViews`**로 변환되어 **`AppWidget`** 시스템 위에서 동작
- **목적**: `RemoteViews`의 제약(호환성/표현력/개발 편의)을 완화하고, 선언적 DSL로 **간결하고 안전**하게 위젯을 작성

---

## 2. 기본 템플릿

```kotlin
class MyWidget : GlanceAppWidget() {
    // 1. 상태 저장 방식 정의
    override val stateDefinition = PreferencesGlanceStateDefinition

    // 2. 크기 대응 전략 정의
    override val sizeMode = SizeMode.Responsive(
        setOf(
            DpSize(180.dp, 110.dp),
            DpSize(250.dp, 150.dp)
        )
    )

    // 3. UI 제공 메서드
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            WidgetContent()
        }
    }

    // 4. 실제 UI 구성
    @Composable
    private fun WidgetContent() {
        val prefs = currentState<Preferences>()
        val count = prefs[intPreferencesKey("count")] ?: 0

        Column(
            modifier = GlanceModifier.fillMaxSize().padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Count: $count",
                style = TextStyle(fontSize = 20.sp, fontWeight = FontWeight.Bold)
            )
            Button(
                text = "Increment",
                onClick = actionRunCallback<IncrementAction>()
            )
        }
    }
}
```

> [!NOTE] 💬 발표 설명
> "기본 템플릿을 보면 GlanceAppWidget의 구조가 명확합니다.
>
> 1. **stateDefinition**: 위젯 상태를 어떻게 저장할지 정합니다. PreferencesGlanceStateDefinition이 가장 간단하고 많이 씁니다.
>
> 2. **sizeMode**: 위젯 크기가 변경될 때 어떻게 대응할지 정합니다. Responsive가 권장 방식입니다.
>
> 3. **provideGlance()**: 위젯이 업데이트될 때마다 호출됩니다. 여기서 `provideContent` 블록으로 UI를 제공하죠.
>
> 4. **WidgetContent()**: 실제 UI를 Compose 스타일로 작성합니다. `currentState()`로 상태를 읽고, Column/Text/Button 같은 컴포넌트로 화면을 구성합니다.
>
> 핵심은 **provideGlance()가 호출되는 시점**을 이해하는 겁니다. 위젯 추가, 업데이트, 크기 변경, 상태 변경 후 update() 호출 등 여러 상황에서 호출됩니다."

---

## 3. 핵심 구성 요소

### 3.1 `stateDefinition`
위젯 상태 저장 방식을 정의합니다.

```kotlin
// Preferences 기반 (간단한 key-value) - 가장 일반적
override val stateDefinition = PreferencesGlanceStateDefinition
```

**상태 관리에 대한 자세한 내용은 → [10. State 관리⭐](10.%20State%20관리⭐.md)** 참고

---

### 3.2 `sizeMode`
위젯이 다양한 크기에서 어떻게 동작할지 정의합니다.

```kotlin
// 반응형 (권장)
override val sizeMode = SizeMode.Responsive(
    setOf(
        DpSize(180.dp, 110.dp),
        DpSize(250.dp, 150.dp)
    )
)
```

**SizeMode에 대한 자세한 내용은 → [7. SizeMode](7.%20SizeMode.md)** 참고

---

### 3.3 `provideGlance()`
시스템이 '위젯을 그려라' 하고 호출할 때 실행되는 메서드입니다.

```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    // 1. 필요한 데이터 로드 (suspend 함수 사용 가능)
    val data = loadWidgetData()

    // 2. UI 제공
    provideContent {
        WidgetUI(data)
    }
}
```

**특징**
- `suspend` 함수로 정의됨 → 네트워크/DB 호출 가능
- `context`: Android Context
- `id`: 위젯 인스턴스를 구분하는 고유 ID (`GlanceId`)

---

### 3.4 `provideContent {}`
Glance DSL로 UI를 작성하는 블록입니다.

```kotlin
provideContent {
    // Glance Composable 사용
    Column {
        Text("Hello")
        Button("Click", onClick = { /* ... */ })
    }
}
```

---

## 4. UI 작성 규칙

### 4.1 사용 가능한 컴포넌트

**레이아웃**
- `Column`: 세로 배치
- `Row`: 가로 배치
- `Box`: 겹쳐서 배치
- `Spacer`: 빈 공간
- `LazyColumn`: 스크롤 가능한 리스트 (제한적)

**UI 요소**
- `Text`: 텍스트
- `Image`: 이미지
- `Button`: 버튼
- `CheckBox`: 체크박스
- `Switch`: 스위치
- `RadioButton`: 라디오 버튼

**UI 작성 규칙에 대한 자세한 내용은 → [6. UI 작성 규칙 및 제약사항⭐](6.%20UI%20작성%20규칙%20및%20제약사항⭐.md)** 참고

---

### 4.2 단위 사용

Glance에서는 **`androidx.glance.unit.dp`**를 사용합니다 (Compose의 `dp`와 다름).

```kotlin
import androidx.glance.unit.dp  // ✅ Glance의 dp

// ❌ 잘못된 예
import androidx.compose.ui.unit.dp  // Compose의 dp (Glance에서 사용 불가)
```

---

### 4.3 상태 접근

`currentState<T>()`로 현재 위젯의 상태를 읽습니다.

```kotlin
@Composable
fun WidgetContent() {
    val prefs = currentState<Preferences>()
    val count = prefs[intPreferencesKey("count")] ?: 0

    Text("Count: $count")
}
```

---

## 5. RemoteViews 제약 (Compose와 다름)

Glance는 `RemoteViews` 기반이므로 다음과 같은 제약이 있습니다:

- ❌ `remember`, `LaunchedEffect` 등 Compose 런타임 API 사용 불가
- ❌ 애니메이션 제한
- ❌ Coil/Glide 직접 사용 불가

```kotlin
// ❌ 사용 불가
var count by remember { mutableStateOf(0) }

// ✅ 대신 StateDefinition 사용
val prefs = currentState<Preferences>()
val count = prefs[intPreferencesKey("count")] ?: 0
```

**RemoteViews 제약에 대한 자세한 내용은 → [6. UI 작성 규칙 및 제약사항⭐](6.%20UI%20작성%20규칙%20및%20제약사항⭐.md)** 참고

---

## 6. 실전 예제: 날씨 위젯

```kotlin
class WeatherWidget : GlanceAppWidget() {
    override val stateDefinition = PreferencesGlanceStateDefinition

    override val sizeMode = SizeMode.Responsive(
        setOf(
            DpSize(180.dp, 110.dp),  // 작은 크기
            DpSize(250.dp, 200.dp)   // 큰 크기
        )
    )

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            WeatherContent()
        }
    }

    @Composable
    private fun WeatherContent() {
        val prefs = currentState<Preferences>()
        val temperature = prefs[stringPreferencesKey("temperature")] ?: "N/A"
        val condition = prefs[stringPreferencesKey("condition")] ?: "Unknown"
        val size = LocalSize.current

        Column(
            modifier = GlanceModifier
                .fillMaxSize()
                .background(Color.LightGray)
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = temperature,
                style = TextStyle(
                    fontSize = if (size.width > 200.dp) 32.sp else 24.sp,
                    fontWeight = FontWeight.Bold
                )
            )
            Spacer(GlanceModifier.height(8.dp))
            Text(text = condition)

            if (size.width > 200.dp) {
                Spacer(GlanceModifier.height(16.dp))
                Button(
                    text = "Refresh",
                    onClick = actionRunCallback<RefreshWeatherAction>()
                )
            }
        }
    }
}
```

**[스크린샷 추천]** 날씨 위젯의 작은 크기/큰 크기 버전

---

## 7. initialLayout 플레이스홀더 (필수 설정)

위젯을 추가할 때 Glance가 실제 UI를 렌더링하기 전까지 **임시로 보여줄 레이아웃**을 설정해야 합니다.

### 7.1 플레이스홀더 설정

```xml
<!-- res/xml/widget_info.xml -->
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_placeholder"  <!-- 필수! -->
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:previewImage="@drawable/widget_preview"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen" />
```

```xml
<!-- res/layout/widget_placeholder.xml -->
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:text="Loading..."
    android:gravity="center"
    android:textColor="#666666"
    android:background="#FFFFFF" />
```

> [!NOTE] 💬 발표 설명
> "`initialLayout`은 **필수 설정**입니다. 이 리소스가 없으면 위젯이 위젯 선택 화면에 아예 안 나타날 수 있어요.
>
> 사용자가 위젯을 추가하는 순간, Glance가 `provideGlance()`를 실행해서 실제 UI를 만들기 전까지 잠깐 보여줄 임시 화면입니다. 'Loading...' 같은 단순한 텍스트나 로고 정도면 충분합니다.
>
> 실제로는 몇 밀리초~1초 정도만 보이지만, 이 파일 자체가 없으면 시스템이 위젯을 인식하지 못합니다."

### 7.2 주의사항

- ✅ **반드시 생성**: XML 레이아웃 파일이 실제로 존재해야 함
- ✅ **단순하게**: TextView 하나 정도로 충분
- ✅ **빠른 로딩**: 무거운 레이아웃 피하기
- ⚠️ **미노출 위험**: 없으면 위젯 목록에 안 뜰 수 있음

---

## 8. Glance 동작 원리

### 8.1 렌더링 흐름

```
📱 사용자가 위젯 추가
   ↓
📑 initialLayout 즉시 표시 (플레이스홀더)
   ↓
📡 GlanceAppWidgetReceiver 호출
   ↓
🧩 provideGlance() 실행
   ↓
🎨 provideContent { } - Glance DSL 작성
   ↓
🔄 Glance 엔진이 자동으로 RemoteViews 변환
   ↓
✅ 실제 위젯 UI 표시
```

### 8.2 핵심 포인트

- **선언형 UI**: 개발자는 DSL만 작성
- **자동 변환**: Glance가 RemoteViews로 변환
- **RemoteViews 기반**: 따라서 제약사항 존재 (→ [6. UI 작성 규칙](4.세미나/Glance/6.%20UI%20작성%20규칙%20및%20제약사항⭐⭐.md) 참고)

---

## 9. 체크리스트

- [ ] `GlanceAppWidget` 상속한 클래스 작성
- [ ] `stateDefinition` 정의 (Preferences 또는 Proto)
- [ ] `sizeMode` 정의 (대부분 Responsive 권장)
- [ ] `provideGlance()` 구현
- [ ] `provideContent {}` 내부에 Glance Composable 작성
- [ ] **`initialLayout` XML 파일 생성** (필수!)
- [ ] Glance의 `dp` 사용 확인 (`androidx.glance.unit.dp`)
- [ ] Compose 런타임 API 사용하지 않았는지 확인
- [ ] `currentState<T>()`로 상태 접근

---

---
