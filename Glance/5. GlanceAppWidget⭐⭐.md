> [!TIP] 🗣️ 핵심내용
실제 위젯의 UI와 동작을 정의하는 핵심 클래스입니다. `provideGlance()` 함수에서 위젯 컨텐츠를 구성합니다.
>

## 1. GlanceAppWidget이란?

`GlanceAppWidget`은 기존 홈 화면 위젯(`AppWidget`)을 **Compose스러운 DSL**로 작성할 수 있게 해주는 Jetpack 라이브러리의 핵심 베이스 클래스입니다.

### 1.1 핵심 개념
- 위젯 개발의 **진입점**
- 화면에는 Compose가 직접 그려지는 게 아니라, Glance DSL → **`RemoteViews`**로 변환되어 **`AppWidget`** 시스템 위에서 동작
- **목적**: `RemoteViews`의 제약(호환성/표현력/개발 편의)을 완화하고, 선언적 DSL로 **간결하고 안전**하게 위젯을 작성

---

## 2. 기본 템플릿

```kotlin
class MyWidget : GlanceAppWidget() {
    // 1. 상태 저장 방식 정의
    override val stateDefinition = PreferencesGlanceStateDefinition

    // 2. 크기 대응 전략 정의
    override val sizeMode = SizeMode.Responsive(
        setOf(
            DpSize(180.dp, 110.dp),
            DpSize(250.dp, 150.dp)
        )
    )

    // 3. UI 제공 메서드
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            WidgetContent()
        }
    }

    // 4. 실제 UI 구성
    @Composable
    private fun WidgetContent() {
        val prefs = currentState<Preferences>()
        val count = prefs[intPreferencesKey("count")] ?: 0

        Column(
            modifier = GlanceModifier.fillMaxSize().padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Count: $count",
                style = TextStyle(fontSize = 20.sp, fontWeight = FontWeight.Bold)
            )
            Button(
                text = "Increment",
                onClick = actionRunCallback<IncrementAction>()
            )
        }
    }
}
```

> [!NOTE] 💬 NOTE
> "기본 템플릿을 보면 GlanceAppWidget의 구조가 명확합니다.
>
> 1. **stateDefinition**: 위젯 상태를 어떻게 저장할지 정합니다. PreferencesGlanceStateDefinition이 가장 간단하고 많이 씁니다.
>
> 2. **sizeMode**: 위젯 크기가 변경될 때 어떻게 대응할지 정합니다. Responsive가 권장 방식입니다.
>
> 3. **provideGlance()**: 위젯이 업데이트될 때마다 호출됩니다. 여기서 `provideContent` 블록으로 UI를 제공하죠.
>
> 4. **WidgetContent()**: 실제 UI를 Compose 스타일로 작성합니다. `currentState()`로 상태를 읽고, Column/Text/Button 같은 컴포넌트로 화면을 구성합니다.
>
> 핵심은 **provideGlance()가 호출되는 시점**을 이해하는 겁니다. 위젯 추가, 업데이트, 크기 변경, 상태 변경 후 update() 호출 등 여러 상황에서 호출됩니다."

---

## 3. 핵심 구성 요소

### 3.1 `stateDefinition`
위젯 상태 저장 방식을 정의합니다.

```kotlin
// Preferences 기반 (간단한 key-value) - 가장 일반적
override val stateDefinition = PreferencesGlanceStateDefinition
```

**상태 관리에 대한 자세한 내용은 → [6. State 관리⭐](6.%20State%20관리⭐.md)** 참고

---

### 3.2 `sizeMode`
위젯이 다양한 크기에서 어떻게 동작할지 정의합니다.

```kotlin
// 반응형 (권장)
override val sizeMode = SizeMode.Responsive(
    setOf(
        DpSize(180.dp, 110.dp),
        DpSize(250.dp, 150.dp)
    )
)
```

**SizeMode에 대한 자세한 내용은 → [8. SizeMode](8.%20SizeMode.md)** 참고

---

### 3.3 `provideGlance()`
시스템이 '위젯을 그려라' 하고 호출할 때 실행되는 메서드입니다.

```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    // ⚠️ 주의: provideContent 외부에서 가벼운 준비 작업만
    // 무거운 I/O는 Worker로 분리 필요

    provideContent {
        // ✅ DataStore에서 상태 읽기만
        val prefs = currentState<Preferences>()
        val data = prefs[dataKey] ?: "기본값"

        WidgetUI(data)
    }
}
```

**특징**
- `suspend` 함수로 정의되지만 **무거운 I/O는 금지**
- `context`: Android Context
- `id`: 위젯 인스턴스를 구분하는 고유 ID (`GlanceId`)

---

### 3.4 `provideContent {}` - UI 선언 전용 구간

#### 3.4.1 기본 사용법

Glance DSL로 UI를 작성하는 블록입니다. **RemoteViews로 변환될 UI 트리만 선언**하는 단계입니다.

```kotlin
provideContent {
    // Glance Composable 사용
    Column {
        Text("Hello")
        Button("Click", onClick = { /* ... */ })
    }
}
```

#### 3.4.2 ⚠️ 중요: provideContent에서 네트워크 호출 금지

> [!WARNING] 왜 provideContent에서 네트워크/I/O를 하면 안 되나요?
>
> **1. RemoteViews 변환 구간의 특성**
> - `provideContent`는 **"RemoteViews로 변환될 UI 트리만 선언"**하는 단계입니다.
> - Compose 런타임 기능(`remember`, `LaunchedEffect`, 코루틴 컨텍스트)이 동작하지 않습니다.
> - UI 선언 중에 블로킹/I/O가 끼면 **렌더링 실패 또는 지연**이 발생합니다.
>
> **2. 프로세스 제약**
> - 위젯은 **런처 프로세스와 IPC로 그려지는** 별도 프로세스/스레드 환경입니다.
> - 이 환경에서 네트워크/DB 호출은 **안정적이지 않고**, ANR(Application Not Responding) 위험이 있습니다.
>
> **3. 올바른 패턴**
> ```kotlin
> ❌ 잘못된 예 - provideContent 내부에서 네트워크 호출
> provideContent {
>     val data = runBlocking { fetchDataFromNetwork() } // ❌ ANR 위험!
>     Text(data)
> }
>
> ✅ 올바른 예 - Worker에서 준비 → DataStore 저장 → UI는 읽기만
> // 1. Worker에서 데이터 가져오기
> class DataUpdateWorker : CoroutineWorker(...) {
>     override suspend fun doWork(): Result {
>         val data = repository.fetchData() // 네트워크 호출
>
>         // DataStore에 저장
>         updateAppWidgetState(context, glanceId) { prefs ->
>             prefs[dataKey] = data
>         }
>
>         // UI 갱신 트리거
>         MyWidget().update(context, glanceId)
>         return Result.success()
>     }
> }
>
> // 2. UI는 currentState()로 읽기만
> provideContent {
>     val prefs = currentState<Preferences>()
>     val data = prefs[dataKey] ?: "로딩 중..."
>     Text(data)
> }
> ```
>
> **정리**: 데이터는 Worker/Repository에서 준비 → DataStore에 저장 → UI는 `currentState()`로 읽기만.

#### 3.4.3 최초 로딩 UX 권장 패턴
위젯이 처음 추가되었을 때 데이터가 없는 상태를 처리하는 패턴입니다.

```kotlin
@Composable  
fun WidgetContent() {  
    val prefs = currentState<Preferences>()  
    val data = prefs[stringPreferencesKey("weather_data")]  
    val isLoading = prefs[booleanPreferencesKey("is_loading")] ?: false  
    val errorMsg = prefs[stringPreferencesKey("error_message")]  
  
    Column(  
        modifier = GlanceModifier.fillMaxSize().padding(16.dp),  
        verticalAlignment = Alignment.CenterVertically,  
        horizontalAlignment = Alignment.CenterHorizontally  
    ) {  
        when {  
            errorMsg != null -> {  
                Text("⚠️ $errorMsg", style = TextStyle(color = Color.Red))  
                Spacer(GlanceModifier.height(8.dp))  
                Button(text = "새로고침", onClick = actionRunCallback<RefreshDataAction>())  
            }  
            isLoading -> {  
                CircularProgressIndicator()  
                Text("로딩 중...", style = TextStyle(color = Color.Gray))  
            }  
            data == null -> {  
                Text("📊 데이터를 불러오려면\n아래 버튼을 눌러주세요")  
                Spacer(GlanceModifier.height(8.dp))  
                Button(text = "데이터 불러오기", onClick = actionRunCallback<LoadInitialDataAction>())  
            }  
            else -> {  
                Text(data)  
                Button(text = "새로고침", onClick = actionRunCallback<RefreshDataAction>())  
            }  
        }  
    }  
}  
  
class LoadInitialDataAction : ActionCallback {  
    override suspend fun onAction(  
        context: Context,  
        glanceId: GlanceId,  
        parameters: ActionParameters  
    ) {  
        // 1) UX 반응성: 현재 인스턴스만 로딩 표시  
        updateAppWidgetState(context, glanceId) { prefs ->  
            prefs[booleanPreferencesKey("is_loading")] = true  
            prefs.remove(stringPreferencesKey("error_message"))  
        }  
        MyWidget().update(context, glanceId)  
  
        // 2) Worker에는 'glance_id' 전달 없이 전체 갱신 전략  
        WorkManager.getInstance(context).enqueue(  
            OneTimeWorkRequestBuilder<DataFetchWorker>().build()  
        )  
    }  
}  
  
// 새로고침 버튼도 동일 전략 사용  
class RefreshDataAction : ActionCallback {  
    override suspend fun onAction(  
        context: Context,  
        glanceId: GlanceId,  
        parameters: ActionParameters  
    ) {  
        updateAppWidgetState(context, glanceId) { prefs ->  
            prefs[booleanPreferencesKey("is_loading")] = true  
            prefs.remove(stringPreferencesKey("error_message"))  
        }  
        MyWidget().update(context, glanceId)  
  
        WorkManager.getInstance(context).enqueue(  
            OneTimeWorkRequestBuilder<DataFetchWorker>().build()  
        )  
    }  
}
```

**[스크린샷 추천]** 위젯 로딩 → 데이터 표시 → 에러 → 재시도 흐름

> [!NOTE] 💬 NOTE
> "**최초 로딩 UX는 4가지 상태**를 처리해야 합니다.
>
> 1. **에러 상태**: 네트워크 오류 등의 메시지와 '새로고침' 버튼
> 2. **로딩 중**: 로딩 인디케이터나 '로딩 중...' 텍스트
> 3. **초기 상태**: 데이터가 없을 때 '데이터 불러오기' 버튼
> 4. **정상 상태**: 실제 데이터 표시
>
> **핵심 패턴**:
> - ActionCallback에서 즉시 로딩 상태로 변경 → `update()` 호출 (사용자에게 피드백)
> - Worker를 enqueue해서 백그라운드 작업 위임
> - Worker가 완료되면 DataStore 업데이트 → `update()` 호출 (결과 반영)
>
> 이렇게 하면 **UI는 절대 블로킹되지 않고**, 사용자는 로딩 상태를 명확히 인지할 수 있습니다."

**Worker 구현 예시**:
```kotlin
class DataFetchWorker(  
    context: Context,  
    params: WorkerParameters  
) : CoroutineWorker(context, params) {  
  
    override suspend fun doWork(): Result = try {  
        // 1) 무거운 I/O (한 번만 수행)  
        val data = repository.fetchWeatherData()  
  
        // 2) 모든 인스턴스에 상태 반영  
        val appContext = applicationContext  
        val widget = MyWidget()  
        val manager = GlanceAppWidgetManager(appContext)  
        val glanceIds = manager.getGlanceIds(widget.javaClass)  
  
        glanceIds.forEach { id ->  
            updateAppWidgetState(appContext, id) { prefs ->  
                prefs[stringPreferencesKey("weather_data")] = data  
                prefs[booleanPreferencesKey("is_loading")] = false  
                prefs.remove(stringPreferencesKey("error_message"))  
            }  
        }  
        // 3) 전체 재렌더  
        widget.updateAll(appContext)  
        Result.success()  
  
    } catch (e: Exception) {  
        // 에러 상태도 모든 인스턴스에 반영  
        val appContext = applicationContext  
        val widget = MyWidget()  
        val manager = GlanceAppWidgetManager(appContext)  
        val glanceIds = manager.getGlanceIds(widget.javaClass)  
  
        glanceIds.forEach { id ->  
            updateAppWidgetState(appContext, id) { prefs ->  
                prefs[booleanPreferencesKey("is_loading")] = false  
                prefs[stringPreferencesKey("error_message")] =  
                    e.message ?: "알 수 없는 오류"  
            }  
        }        widget.updateAll(appContext)  
        Result.failure()  
    }  
}
```

> [!NOTE] 💬 워커에서 개별 업데이트 방법?
>  Worker 예시 코드에서 특정 위젯의 개별업데이트 방법에 대한 공식가이드
>  - AppWidgetId는 라이브러리 그룹으로 존재함
>  - 공식으로는 id를 순회하거나 전체 updateAll을 하는 가이드만 존재
>  - GlanceAppWidgetManager통해 id를 얻는 방법이 있지만 이후 호환성 문제 발생 우려
>  - 추후 관련 내용의 업데이트가 생길 수도 있어 보임

```kotlin
val glanceIdString = inputData.getString("glance_id") ?: return Result.failure()  
val glanceId = GlanceAppWidgetManager(applicationContext)  
    .getGlanceIds(MyGlanceWidget::class.java)  
    .find { it.toString() == glanceIdString }  
    ?: return Result.failure()
```
---

## 4. Glance 동작 원리

### 4.1 렌더링 흐름

```
📱 사용자가 위젯 추가
   ↓
📑 initialLayout 즉시 표시 (플레이스홀더)
   ↓
📡 GlanceAppWidgetReceiver 호출
   ↓
🧩 provideGlance() 실행
   ↓
🎨 provideContent { } - Glance DSL 작성
   ↓
🔄 Glance 엔진이 자동으로 RemoteViews 변환
   ↓
✅ 실제 위젯 UI 표시
```

> [!NOTE]
> **initialLayout 플레이스홀더**에 대한 자세한 설명은 → **[2. GlanceAppWidgetReceiver⭐](2.%20GlanceAppWidgetReceiver⭐.md)** 섹션 2.1 참고

### 4.2 핵심 포인트

- **선언형 UI**: 개발자는 DSL만 작성
- **자동 변환**: Glance가 RemoteViews로 변환
- **RemoteViews 기반**: 따라서 제약사항 존재 (→ [7. UI 작성 규칙](7.%20UI%20작성%20규칙%20및%20제약사항⭐⭐.md) 참고)

### 4.3 프로세스 및 인스턴스 관리

#### 4.3.1 프로세스 분리

위젯은 **별도 프로세스**에서 실행됩니다. 이 프로세스는 자주 종료될 수 있습니다.

**권장 사항**:
- 무거운 I/O/네트워크 작업은 `Worker`나 `Repository`로 분리
- `provideContent`는 빠르게 `RemoteViews`를 생성해야 함 (블로킹 금지)

> [!TIP]
> 위젯 프로세스는 런처 프로세스와 별도로 동작하며, 시스템 리소스 압박 시 언제든 종료될 수 있습니다. 따라서 상태는 항상 DataStore에 저장하고, 무거운 작업은 Worker로 분리해야 합니다.

#### 4.3.2 여러 인스턴스 관리

홈 화면에 같은 위젯을 여러 개 추가하면 각각 다른 `GlanceId`를 가집니다.

```kotlin
// 인스턴스별로 독립적인 상태
updateAppWidgetState(context, glanceId1) { prefs ->
    prefs[stringPreferencesKey("location")] = "서울"
}

updateAppWidgetState(context, glanceId2) { prefs ->
    prefs[stringPreferencesKey("location")] = "부산"
}

// 각 인스턴스는 독립적으로 업데이트
MyWidget().update(context, glanceId1)  // 서울 날씨만 갱신
MyWidget().update(context, glanceId2)  // 부산 날씨만 갱신
```

> [!NOTE]
> 각 위젯 인스턴스는 고유한 `GlanceId`를 가지며, DataStore도 인스턴스별로 독립적으로 관리됩니다. 이를 통해 같은 위젯을 여러 개 추가해도 각각 다른 설정과 데이터를 가질 수 있습니다.

---