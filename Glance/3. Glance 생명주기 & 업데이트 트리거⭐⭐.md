> [!TIP] 🗣️ 핵심내용
위젯이 생성, 업데이트, 삭제되는 과정과 수동/자동 업데이트 방법을 이해합니다.
>

## 1. 위젯 생명주기 개요

Glance 위젯은 Android 시스템과 상호작용하며 다음과 같은 생명주기를 가집니다.

```
📱 위젯 생명주기
┌─────────────────────────────────────┐
│  사용자가 홈 화면에 위젯 추가              │
└──────────────┬──────────────────────┘
               ▼
    ┌──────────────────────┐
    │   onEnabled()        │ ← 첫 번째 위젯 인스턴스 추가 시 1회
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │   onUpdate()         │ ← 각 위젯 인스턴스마다 호출
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │ provideGlance()      │ ← UI 생성
    └──────────┬───────────┘
               ▼
         [위젯 표시]
               │
    ┌──────────▼───────────┐
    │  사용자 인터랙션         │
    │  - 버튼 클릭           │
    │  - 리사이즈            │
    │  - 설정 변경           │
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │   update()           │ ← 수동 업데이트
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │ provideGlance()      │ ← UI 재생성
    └──────────────────────┘
               │
    ┌──────────▼───────────┐
    │ 사용자가 위젯 삭제       │
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │   onDeleted()        │ ← 각 위젯 삭제 시
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │   onDisabled()       │ ← 마지막 위젯 삭제 시 1회
    └──────────────────────┘
```

> [!NOTE] 💬 NOTE
> "위젯 생명주기를 이해하는 게 중요합니다. 플로우차트를 보면 전체 흐름이 보입니다.
>
> **최초 추가**: 사용자가 위젯을 처음 추가하면 `onEnabled()` → `onUpdate()` → `provideGlance()` 순서로 호출됩니다. `onEnabled`는 딱 한 번만 호출되고, 이때 WorkManager 같은 전역 리소스를 설정합니다.
>
> **업데이트**: 이후 업데이트는 `update()` → `provideGlance()` 흐름입니다. 상태를 변경하고 `update()`를 호출하면 `provideGlance`가 다시 실행되면서 UI가 새로 그려집니다.
>
> **삭제**: 위젯을 삭제하면 `onDeleted()`가 호출되고, 마지막 위젯이 삭제되면 `onDisabled()`가 호출됩니다. 여기서 WorkManager를 취소하거나 상태 파일을 정리합니다.
>
> 핵심은 **onEnabled/onDisabled는 전역 리소스**, **onDeleted는 인스턴스별 정리**라는 점입니다."

---

## 2. Receiver 생명주기 콜백

### 2.1 onEnabled()

**첫 번째 위젯 인스턴스가 추가될 때 1회만 호출**됩니다.

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    override val glanceAppWidget: GlanceAppWidget = MyWidget()

    override fun onEnabled(context: Context) {
        super.onEnabled(context)
        Log.d("WidgetLifecycle", "첫 위젯 추가됨")

        // 전역 초기화 작업
        // - WorkManager 예약
        // - 데이터베이스 초기화
        // - 리소스 준비
        schedulePeriodicUpdates(context)
    }

    private fun schedulePeriodicUpdates(context: Context) {
        val updateRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
            repeatInterval = 30,
            repeatIntervalTimeUnit = TimeUnit.MINUTES
        ).build()

        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            "widget_update",
            ExistingPeriodicWorkPolicy.KEEP,
            updateRequest
        )
    }
}
```

---

### 2.2 onUpdate()

**위젯이 업데이트되어야 할 때 호출**됩니다.

**호출 시점**:
- 위젯 처음 추가될 때
- updatePeriodMillis 주기 도래 시 (30분 이상, 신뢰도 낮음)
- 시스템 재부팅 후
- 수동으로 `AppWidgetManager.updateAppWidget()` 호출 시

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    override val glanceAppWidget: GlanceAppWidget = MyWidget()

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        
        Log.d("WidgetLifecycle", "onUpdate called for ${appWidgetIds.size} widgets")

        // 각 위젯 인스턴스 초기화
        appWidgetIds.forEach { appWidgetId ->
            val glanceId = GlanceAppWidgetManager(context).getGlanceIdBy(appWidgetId)

            CoroutineScope(Dispatchers.IO).launch {
                // 초기 상태 설정
                updateAppWidgetState(context, glanceId) { prefs ->
                    prefs[longPreferencesKey("created_at")] = System.currentTimeMillis()
                    prefs[intPreferencesKey("count")] = 0
                }

                // UI 갱신
                super.onUpdate(context, appWidgetManager, appWidgetIds)
            }
        }
    }
}
```

---

### 2.3 onDeleted()

**위젯 인스턴스가 삭제될 때 호출**됩니다.

```kotlin
override fun onDeleted(context: Context, appWidgetIds: IntArray) {
    super.onDeleted(context, appWidgetIds)
    Log.d("WidgetLifecycle", "위젯 삭제: ${appWidgetIds.size}개")

    appWidgetIds.forEach { appWidgetId ->
        val glanceId = GlanceAppWidgetManager(context).getGlanceIdBy(appWidgetId)

        CoroutineScope(Dispatchers.IO).launch {
            // 1. 상태 파일 삭제
            val stateFile = context.dataStoreFile("glance_$glanceId")
            if (stateFile.exists()) {
                stateFile.delete()
                Log.d("WidgetLifecycle", "상태 파일 삭제: $glanceId")
            }

            // 2. 데이터베이스 정리
            database.widgetDao().deleteByGlanceId(glanceId.toString())

            // 3. 캐시 정리
            clearWidgetCache(glanceId)
        }
    }
}
```

---

### 2.4 onDisabled()

**마지막 위젯 인스턴스가 삭제될 때 1회만 호출**됩니다.

```kotlin
override fun onDisabled(context: Context) {
    super.onDisabled(context)
    Log.d("WidgetLifecycle", "마지막 위젯 삭제됨")

    // 전역 정리 작업
    // - WorkManager 취소
    // - 리소스 해제
    // - 알림 취소
    WorkManager.getInstance(context).cancelUniqueWork("widget_update")
}
```

---

## 3. 업데이트 트리거 방법

### 3.1 수동 업데이트: update() / updateAll()

#### 3.1.1 단일 위젯 업데이트

```kotlin
class RefreshAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 데이터 가져오기
        val newData = fetchDataFromApi()

        // 2. 상태 업데이트
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[stringPreferencesKey("data")] = newData
            prefs[longPreferencesKey("last_update")] = System.currentTimeMillis()
        }

        // 3. UI 갱신 (필수!)
        MyWidget().update(context, glanceId)
    }
}
```

#### 3.1.2 모든 위젯 인스턴스 업데이트

```kotlin
class RefreshAllAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val manager = GlanceAppWidgetManager(context)
        val glanceIds = manager.getGlanceIds(MyWidget::class.java)

        glanceIds.forEach { id ->
            updateAppWidgetState(context, id) { prefs ->
                prefs[longPreferencesKey("sync_time")] = System.currentTimeMillis()
            }
        }

        // 모든 위젯 한 번에 갱신
        MyWidget().updateAll(context)
    }
}
```

---

### 3.2 WorkManager를 통한 주기적 업데이트 (권장)

#### 3.2.1 Worker 구현

```kotlin
class WidgetUpdateWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        Log.d("WidgetUpdateWorker", "주기적 업데이트 시작")

        return try {
            // 1. 데이터 가져오기
            val data = fetchDataFromServer()

            // 2. 모든 위젯 업데이트
            val manager = GlanceAppWidgetManager(applicationContext)
            val glanceIds = manager.getGlanceIds(MyWidget::class.java)

            glanceIds.forEach { glanceId ->
                updateAppWidgetState(applicationContext, glanceId) { prefs ->
                    prefs[stringPreferencesKey("server_data")] = data
                    prefs[longPreferencesKey("last_sync")] = System.currentTimeMillis()
                }
            }

            // 3. UI 갱신
            MyWidget().updateAll(applicationContext)

            Log.d("WidgetUpdateWorker", "업데이트 성공")
            Result.success()
        } catch (e: Exception) {
            Log.e("WidgetUpdateWorker", "업데이트 실패", e)
            Result.retry()
        }
    }
}
```

#### 3.2.2 Worker 예약 (onEnabled에서)

```kotlin
private fun schedulePeriodicUpdates(context: Context) {
    val constraints = Constraints.Builder()
        .setRequiredNetworkType(NetworkType.CONNECTED)  // 네트워크 필요
        .setRequiresBatteryNotLow(true)                // 배터리 충분할 때만
        .build()

    val updateRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
        repeatInterval = 30,  // 최소 15분
        repeatIntervalTimeUnit = TimeUnit.MINUTES
    )
        .setConstraints(constraints)
        .setBackoffCriteria(
            BackoffPolicy.EXPONENTIAL,
            WorkRequest.MIN_BACKOFF_MILLIS,
            TimeUnit.MILLISECONDS
        )
        .build()

    WorkManager.getInstance(context).enqueueUniquePeriodicWork(
        "widget_periodic_update",
        ExistingPeriodicWorkPolicy.KEEP,  // 기존 작업 유지
        updateRequest
    )
}
```

---

## 4. 시스템 이벤트에 따른 업데이트

### 4.1 화면 크기 변경 (리사이즈)

```kotlin
class Step1WidgetReceiver : GlanceAppWidgetReceiver() { 
....

override fun onAppWidgetOptionsChanged(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int,
    newOptions: Bundle
) {
    super.onAppWidgetOptionsChanged(context, appWidgetManager, appWidgetId, newOptions)

    val minWidth = newOptions.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH)
    val minHeight = newOptions.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT)
    Log.d("WidgetResize", "Widget resized: ${minWidth}x${minHeight}")
    
    // ❌ 수동 update()는 불필요 (Glance가 자동으로 provideGlance 호출)
    // ✅ 하지만 특정 조건에서는 커스텀 작업 수행 가능
    if (minWidth > 300 && minHeight > 200) {
        // 예: 큰 사이즈에서는 추가 데이터 요청
        WorkManager.getInstance(context)
            .enqueueUniqueWork("widget_prefetch", ExistingWorkPolicy.REPLACE, fetchWork)
    }
}
}
```
> [!NOTE] 💬 NOTE
> > 전통(RemoteViews)에서는 onAppWidgetOptionsChanged()를 오버라이드해 **수동으로** 레이아웃을 바꿨지만, **Glance**에서는 크기 변경 시 provideGlance()가 **자동 재호출**되고, 위젯 클래스의 sizeMode와 LocalSize.current를 기준으로 **동적 레이아웃을 선택**하면 됩니다.

---

### 4.2 재부팅 후 복원

```xml
<!-- AndroidManifest.xml -->
<receiver
    android:name=".BootCompletedReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
    </intent-filter>
</receiver>
```

```kotlin
class BootCompletedReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            // WorkManager 재등록
            schedulePeriodicUpdates(context)

            // 모든 위젯 즉시 업데이트
            CoroutineScope(Dispatchers.IO).launch {
                MyWidget().updateAll(context)
            }
        }
    }
}
```

---
