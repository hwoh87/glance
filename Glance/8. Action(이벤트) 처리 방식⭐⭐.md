> [!TIP] 🗣️ 핵심내용
사용자 인터랙션을 처리하는 방법: actionRunCallback, actionStartActivity, actionStartService 등을 다룹니다.
>

## 1. Action 개요

Glance 위젯에서 사용자의 클릭, 탭 등의 인터랙션을 처리하는 방법입니다. RemoteViews 기반이므로 PendingIntent를 통해 동작합니다.

```
👆 사용자 클릭
   │
   ▼
🎯 clickable(onClick = action...)
   │
   ▼
📡 PendingIntent 실행
   │
   ├─→ 🔄 `actionRunCallback` (위젯 내부 로직)
   ├─→ 📱 `actionStartActivity` (액티비티 실행)
   └─→ ⚙️ `actionStartService` (서비스 실행)
```

---

## 2. Action 유형

### 2.1 `actionRunCallback`
- **가장 많이 사용**하는 방식
- 위젯 내부에서 **상태 변경 + UI 갱신**을 처리
- `ActionCallback` 인터페이스를 구현한 클래스 필요

```kotlin
class CounterWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val prefs = currentState<Preferences>()
            val count = prefs[intPreferencesKey("count")] ?: 0

            Column(
                modifier = GlanceModifier.fillMaxSize(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text("Count: $count")
                Button(
                    text = "증가",
                    onClick = actionRunCallback<IncrementAction>()
                )
            }
        }
    }
}

// ActionCallback 구현
class IncrementAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 상태 업데이트
        updateAppWidgetState(context, glanceId) { prefs ->
            val current = prefs[intPreferencesKey("count")] ?: 0
            prefs[intPreferencesKey("count")] = current + 1
        }

        // 2. UI 갱신 (필수!)
        CounterWidget().update(context, glanceId)
    }
}
```

> [!NOTE] 💬 발표 설명
> "**ActionCallback의 실행 흐름**을 이해하는 게 중요합니다.
>
> 1. **사용자 클릭**: 사용자가 Button을 탭하면 `onClick = actionRunCallback<IncrementAction>()`이 트리거됩니다.
>
> 2. **시스템 호출**: Glance 시스템이 IncrementAction 클래스를 찾아서 인스턴스를 만들고 `onAction()` 메서드를 호출합니다. 이 과정에서 **리플렉션**이 사용되기 때문에 ProGuard 규칙이 필요한 거죠.
>
> 3. **상태 업데이트**: `updateAppWidgetState()`로 DataStore에 새로운 값을 저장합니다. 하지만 이것만으로는 화면이 안 바뀝니다!
>
> 4. **UI 갱신**: `CounterWidget().update()`를 호출해야 `provideGlance()`가 다시 실행되면서 화면이 업데이트됩니다. **이 단계를 빼먹으면 클릭해도 아무 일도 안 일어나는 것처럼 보입니다.**
>
> **핵심**: ActionCallback은 단순히 로직만 실행하는 게 아니라 '상태 변경 → UI 갱신' 두 단계를 모두 책임집니다."

**[스크린샷 추천]** 버튼 클릭 시 카운터가 증가하는 위젯 화면

---

### 2.2 `actionStartActivity`
- 특정 **Activity를 실행**할 때 사용
- 위젯에서 앱의 메인 화면이나 특정 기능으로 이동

```kotlin
Button(
    text = "앱 열기",
    onClick = actionStartActivity<MainActivity>()
)

// 파라미터 전달
Button(
    text = "상세보기",
    onClick = actionStartActivity(
        Intent(context, DetailActivity::class.java).apply {
            putExtra("item_id", itemId)
        }
    )
)

// ComponentName으로 지정
Button(
    text = "설정 열기",
    onClick = actionStartActivity(
        ComponentName(context, SettingsActivity::class.java)
    )
)
```

---

### 2.3 `actionStartService` (Deprecated)
- Android 8.0(API 26)부터 백그라운드 서비스 제한으로 **사용 권장하지 않음**
- 대신 **WorkManager** 또는 **`actionRunCallback`**에서 작업 처리

```kotlin
// ❌ 권장하지 않음
onClick = actionStartService<MyService>()

// ✅ 대안: actionRunCallback에서 WorkManager 사용
class RefreshAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // WorkManager로 백그라운드 작업 예약
        val workRequest = OneTimeWorkRequestBuilder<RefreshWorker>().build()
        WorkManager.getInstance(context).enqueue(workRequest)

        // UI 즉시 갱신
        MyWidget().update(context, glanceId)
    }
}
```

---

### 2.4 `action` (커스텀 Action)
- 원시적인 방법: 직접 `PendingIntent` 생성
- 특수한 경우에만 사용 (브로드캐스트 수신 등)

```kotlin
Button(
    text = "커스텀 액션",
    onClick = action(
        Intent(context, MyReceiver::class.java).apply {
            action = "com.example.CUSTOM_ACTION"
            putExtra("data", "value")
        }
    )
)
```

---

## 3. `ActionParameters`로 데이터 전달

`ActionCallback`에 파라미터를 전달할 수 있습니다.

```kotlin
// 1. 파라미터 정의
val itemIdKey = ActionParameters.Key<Int>("item_id")

// 2. 클릭 시 파라미터 전달
Button(
    text = "항목 삭제",
    onClick = actionRunCallback<DeleteItemAction>(
        parameters = actionParametersOf(itemIdKey to itemId)
    )
)

// 3. ActionCallback에서 파라미터 수신
class DeleteItemAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val itemId = parameters[itemIdKey] ?: return

        // 삭제 로직
        deleteItem(itemId)

        // UI 갱신
        MyWidget().update(context, glanceId)
    }
}
```

> [!NOTE] 💬 발표 설명
> "**ActionParameters는 RemoteViews의 PendingIntent 제약을 우회하는 방법**입니다.
>
> RemoteViews는 일반적인 Compose처럼 람다로 데이터를 전달할 수 없습니다. 모든 것이 PendingIntent를 통해야 하니까요. 그래서 Glance는 **Key-Value 시스템**을 제공합니다.
>
> 1. **Key 정의**: `ActionParameters.Key<Int>("item_id")` - 타입 안전한 키를 만듭니다.
> 2. **전달**: `actionParametersOf(itemIdKey to itemId)` - 클릭할 때 데이터를 함께 보냅니다.
> 3. **수신**: `parameters[itemIdKey]` - ActionCallback에서 안전하게 꺼냅니다.
>
> 이렇게 하면 리스트 위젯에서 **어떤 항목을 클릭했는지** 구분할 수 있습니다. 같은 ActionCallback 클래스를 재사용하면서도 다른 데이터를 처리할 수 있죠."

**[스크린샷 추천]** 리스트 위젯에서 각 항목의 삭제 버튼 예시

---

## 4. 복합 Action 패턴

### 4.1 조건부 Action
```kotlin
Button(
    text = if (isLoggedIn) "로그아웃" else "로그인",
    onClick = if (isLoggedIn) {
        actionRunCallback<LogoutAction>()
    } else {
        actionStartActivity<LoginActivity>()
    }
)
```

### 4.2 여러 컴포넌트에 동일 Action
```kotlin
@Composable
fun ClickableCard(data: String) {
    Box(
        modifier = GlanceModifier
            .fillMaxWidth()
            .padding(8.dp)
            .background(Color.White)
            .clickable(
                onClick = actionRunCallback<CardClickAction>(
                    parameters = actionParametersOf(dataKey to data)
                )
            )
    ) {
        Text(data)
    }
}
```

---

## 5. Action 처리 시 주의사항

### 5.1 상태 변경 후 반드시 `update()` 호출

상태를 변경한 후에는 **반드시 `update()`를 호출**해야 UI에 반영됩니다.

```kotlin
updateAppWidgetState(context, glanceId) { prefs ->
    prefs[someKey] = newValue
}
MyWidget().update(context, glanceId) // 필수!
```

> [!NOTE] 💬 발표 설명
> "**가장 흔한 실수**가 바로 `update()` 호출을 까먹는 겁니다.
>
> `updateAppWidgetState()`는 DataStore에 데이터만 저장합니다. 파일에 쓰는 것과 비슷해요. **화면 갱신과는 별개입니다.**
>
> `update()`를 호출해야 `provideGlance()`가 다시 실행되고, `currentState<Preferences>()`로 새로운 값을 읽어와서 UI가 다시 그려집니다.
>
> 이 두 단계가 분리된 이유는 **배치 업데이트**를 가능하게 하기 위해서입니다. 여러 상태를 한 번에 바꾸고 마지막에 딱 한 번만 `update()`를 호출하면 되니까요."

**업데이트 메서드에 대한 자세한 내용은 → [5. Glance 생명주기 & 업데이트 트리거⭐](5.%20Glance%20생명주기%20&%20업데이트%20트리거⭐.md)** 참고

### 5.2 무거운 작업은 `Worker`로 분리
```kotlin
class HeavyAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // ✅ 네트워크/DB 작업은 WorkManager로
        val workRequest = OneTimeWorkRequestBuilder<DataSyncWorker>()
            .setInputData(workDataOf("glance_id" to glanceId.toString()))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)

        // 즉시 로딩 상태 표시
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[booleanPreferencesKey("is_loading")] = true
        }
        MyWidget().update(context, glanceId)
    }
}
```

**[비디오 추천]** 버튼 클릭 → 로딩 표시 → 데이터 로드 완료 → 결과 표시 흐름

---

### 5.3 에러 처리
```kotlin
class SafeAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        try {
            // 작업 수행
            performTask()

            updateAppWidgetState(context, glanceId) { prefs ->
                prefs[stringPreferencesKey("status")] = "success"
            }
        } catch (e: Exception) {
            Log.e("SafeAction", "Error", e)
            updateAppWidgetState(context, glanceId) { prefs ->
                prefs[stringPreferencesKey("status")] = "error"
                prefs[stringPreferencesKey("error_msg")] = e.message ?: "Unknown"
            }
        } finally {
            MyWidget().update(context, glanceId)
        }
    }
}
```

---

## 6. 실전 예제: Todo 위젯

```kotlin
class TodoWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val prefs = currentState<Preferences>()
            val todos = prefs[stringPreferencesKey("todos")]?.split("|") ?: emptyList()

            Column(
                modifier = GlanceModifier.fillMaxSize().padding(16.dp)
            ) {
                Text("할 일 목록", style = TextStyle(fontSize = 18.sp, fontWeight = FontWeight.Bold))
                Spacer(GlanceModifier.height(8.dp))

                todos.forEach { todo ->
                    Row(
                        modifier = GlanceModifier.fillMaxWidth().padding(vertical = 4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(todo, modifier = GlanceModifier.defaultWeight())
                        Button(
                            text = "완료",
                            onClick = actionRunCallback<CompleteTodoAction>(
                                parameters = actionParametersOf(todoKey to todo)
                            )
                        )
                    }
                }

                Button(
                    text = "+ 추가",
                    onClick = actionStartActivity<AddTodoActivity>(),
                    modifier = GlanceModifier.fillMaxWidth()
                )
            }
        }
    }
}

class CompleteTodoAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val todoToRemove = parameters[todoKey] ?: return

        updateAppWidgetState(context, glanceId) { prefs ->
            val todos = prefs[stringPreferencesKey("todos")]?.split("|")?.toMutableList() ?: mutableListOf()
            todos.remove(todoToRemove)
            prefs[stringPreferencesKey("todos")] = todos.joinToString("|")
        }

        TodoWidget().update(context, glanceId)
    }
}

private val todoKey = ActionParameters.Key<String>("todo_item")
```

**[스크린샷 추천]** Todo 위젯 전체 UI (목록 + 완료 버튼 + 추가 버튼)

---

---
