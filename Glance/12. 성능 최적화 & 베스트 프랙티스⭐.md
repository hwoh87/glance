> [!TIP] 🗣️ 핵심내용
배터리 효율적인 위젯 설계와 업데이트 빈도 관리, 메모리 최적화 팁을 공유합니다.
>

## 1. 성능 최적화 개요

Glance 위젯은 홈 화면에 상주하며 시스템 리소스를 지속적으로 사용합니다. 배터리, 메모리, CPU 효율을 고려한 설계가 필수입니다.

```
⚡ 위젯 성능 3대 원칙
1. 업데이트 최소화 (배터리)
2. UI 단순화 (렌더링 비용)
3. 무거운 작업 분리 (Worker/Repository)
```

---

## 2. 업데이트 빈도 최적화

### 2.1 불필요한 업데이트 방지

**❌ 나쁜 예: 과도한 업데이트**
```kotlin
// 1초마다 업데이트 (배터리 소모 심각!)
class BadWidget : GlanceAppWidget() {
    init {
        CoroutineScope(Dispatchers.Main).launch {
            while (true) {
                delay(1000)
                updateAll(context) // 매초 실행!
            }
        }
    }
}
```

**✅ 좋은 예: 필요할 때만 업데이트**
```kotlin
class GoodWidget : GlanceAppWidget() {
    // 사용자 트리거로만 업데이트
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            Column {
                Text("Last update: ${getCurrentTime()}")
                Button(
                    text = "새로고침",
                    onClick = actionRunCallback<RefreshAction>()
                )
            }
        }
    }
}

class RefreshAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 데이터 갱신
        fetchNewData()

        // 상태 업데이트
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[longPreferencesKey("last_update")] = System.currentTimeMillis()
        }

        MyWidget().update(context, glanceId)
    }
}
```

---

### 2.2 주기적 업데이트 전략

**방법 1: PeriodicWorkRequest (권장)**
```kotlin
// 15분마다 업데이트 (최소 주기)
class WidgetUpdateWorker(context: Context, params: WorkerParameters)
    : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        return try {
            // 데이터 갱신
            val data = fetchData()

            // 위젯 상태 업데이트
            val manager = GlanceAppWidgetManager(applicationContext)
            val glanceIds = manager.getGlanceIds(MyWidget::class.java)

            glanceIds.forEach { glanceId ->
                updateAppWidgetState(applicationContext, glanceId) { prefs ->
                    prefs[stringPreferencesKey("data")] = data
                }
            }

            // UI 갱신
            MyWidget().updateAll(applicationContext)

            Result.success()
        } catch (e: Exception) {
            Log.e("WidgetUpdateWorker", "Update failed", e)
            Result.retry()
        }
    }
}

// Worker 등록
fun scheduleWidgetUpdates(context: Context) {
    val updateRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
        repeatInterval = 15, // 최소 15분
        repeatIntervalTimeUnit = TimeUnit.MINUTES
    ).setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true) // 배터리 절약
            .build()
    ).build()

    WorkManager.getInstance(context).enqueueUniquePeriodicWork(
        "widget_update",
        ExistingPeriodicWorkPolicy.KEEP,
        updateRequest
    )
}
```

**[스크린샷 추천]** WorkManager 상태 확인 화면 (adb shell dumpsys jobscheduler)

---

### 2.3 조건부 업데이트

```kotlin
class SmartRefreshAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val prefs = context.dataStoreFile("glance_${glanceId}")
            .let { DataStoreFactory.create(PreferencesSerializer) { it } }
            .data.first()

        val lastUpdate = prefs[longPreferencesKey("last_update")] ?: 0L
        val now = System.currentTimeMillis()

        // 5분 이내 업데이트는 스킵
        if (now - lastUpdate < 5 * 60 * 1000) {
            Log.d("SmartRefresh", "Too soon, skipping update")
            return
        }

        // 실제 업데이트 수행
        updateAppWidgetState(context, glanceId) { mutablePrefs ->
            mutablePrefs[longPreferencesKey("last_update")] = now
            // 데이터 갱신...
        }

        MyWidget().update(context, glanceId)
    }
}
```

---

## 3. UI 렌더링 최적화

### 3.1 단순한 레이아웃 유지

**❌ 복잡한 레이아웃 (느림)**
```kotlin
Column {
    repeat(50) { index ->
        Row {
            Image(ImageProvider(R.drawable.icon))
            Column {
                Text("Item $index")
                Text("Description...")
                Row {
                    Button("A", onClick = {})
                    Button("B", onClick = {})
                    Button("C", onClick = {})
                }
            }
        }
    }
}
```

**✅ 단순한 레이아웃 (빠름)**
```kotlin
Column(modifier = GlanceModifier.fillMaxSize().padding(16.dp)) {
    Text("Title", style = TextStyle(fontSize = 18.sp, fontWeight = FontWeight.Bold))
    Spacer(GlanceModifier.height(8.dp))
    Text("Essential info only")
    Button("Action", onClick = actionRunCallback<MainAction>())
}
```

**[비교 추천]** 복잡한 레이아웃 vs 단순한 레이아웃 렌더링 시간 비교

---

### 3.2 조건부 렌더링 최적화

```kotlin
@Composable
fun OptimizedContent() {
    val prefs = currentState<Preferences>()
    val isExpanded = prefs[booleanPreferencesKey("is_expanded")] ?: false
    val dataCount = prefs[intPreferencesKey("data_count")] ?: 0

    Column {
        Text("Title")

        // 필요할 때만 렌더링
        if (isExpanded && dataCount > 0) {
            HeavyContent(dataCount)
        } else {
            Text("Tap to expand")
        }
    }
}

@Composable
fun HeavyContent(count: Int) {
    // 많은 항목이 있을 때만 표시
    Column {
        repeat(minOf(count, 5)) { index ->
            Text("Item $index")
        }
        if (count > 5) {
            Text("... and ${count - 5} more")
        }
    }
}
```

---

### 3.3 이미지 최적화

```kotlin
// ❌ 큰 이미지 직접 로드
Image(
    provider = ImageProvider(R.drawable.large_image), // 5MB 이미지
    contentDescription = "Large"
)

// ✅ 적절한 크기의 이미지
Image(
    provider = ImageProvider(R.drawable.icon_small), // 50KB 이미지
    contentDescription = "Icon",
    modifier = GlanceModifier.size(48.dp)
)

// ✅ 네트워크 이미지는 캐싱 + 리사이징
suspend fun loadOptimizedImage(url: String, targetSize: Int): Bitmap {
    return imageLoader.execute(
        ImageRequest.Builder(context)
            .data(url)
            .size(targetSize, targetSize)
            .diskCachePolicy(CachePolicy.ENABLED)
            .memoryCachePolicy(CachePolicy.ENABLED)
            .build()
    ).drawable?.toBitmap() ?: createPlaceholder()
}
```

**[스크린샷 추천]** 이미지 크기별 메모리 사용량 비교

---

## 4. 메모리 최적화

### 4.1 상태 크기 최소화

**❌ 불필요한 데이터 저장**
```kotlin
updateAppWidgetState(context, glanceId) { prefs ->
    // 전체 JSON 문자열 저장 (수백 KB)
    prefs[stringPreferencesKey("full_data")] = jsonString

    // 비트맵 직접 저장 (수 MB)
    prefs[stringPreferencesKey("image_base64")] = base64EncodedImage
}
```

**✅ 필요한 데이터만 저장**
```kotlin
updateAppWidgetState(context, glanceId) { prefs ->
    // 필수 필드만 저장
    prefs[stringPreferencesKey("title")] = data.title
    prefs[intPreferencesKey("count")] = data.count
    prefs[longPreferencesKey("timestamp")] = data.timestamp

    // 이미지는 URI/경로만 저장
    prefs[stringPreferencesKey("image_uri")] = data.imageUrl
}

// 복잡한 데이터는 Room에 저장
database.widgetDao().insert(WidgetData(glanceId, fullData))
```

---

### 4.2 데이터 정리

```kotlin
class CleanupWidgetDataWorker(context: Context, params: WorkerParameters)
    : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        val manager = GlanceAppWidgetManager(applicationContext)
        val activeGlanceIds = manager.getGlanceIds(MyWidget::class.java)

        // 모든 저장된 상태 파일 확인
        val dataDir = File(applicationContext.filesDir, "datastore")
        dataDir.listFiles()?.forEach { file ->
            val glanceIdInFile = extractGlanceIdFromFilename(file.name)

            // 활성 위젯이 아니면 삭제
            if (glanceIdInFile !in activeGlanceIds.map { it.toString() }) {
                file.delete()
                Log.d("Cleanup", "Deleted orphaned state: ${file.name}")
            }
        }

        return Result.success()
    }
}

// Receiver에서 삭제 시 정리
override fun onDeleted(context: Context, appWidgetIds: IntArray) {
    super.onDeleted(context, appWidgetIds)

    appWidgetIds.forEach { appWidgetId ->
        val glanceId = GlanceAppWidgetManager(context).getGlanceIdBy(appWidgetId)

        // 상태 파일 삭제
        val file = context.dataStoreFile("glance_${glanceId}")
        file.delete()

        // DB 데이터 삭제
        CoroutineScope(Dispatchers.IO).launch {
            database.widgetDao().deleteByGlanceId(glanceId.toString())
        }
    }
}
```

---

## 5. 네트워크 최적화

### 5.1 효율적인 데이터 페칭

```kotlin
class OptimizedDataRepository {
    private val cache = LruCache<String, CachedData>(maxSize = 10)

    suspend fun fetchData(forceRefresh: Boolean = false): WidgetData {
        val cacheKey = "widget_data"

        // 캐시 확인
        if (!forceRefresh) {
            cache.get(cacheKey)?.let { cached ->
                val ageMinutes = (System.currentTimeMillis() - cached.timestamp) / 60000
                if (ageMinutes < 15) {
                    Log.d("Repository", "Using cached data (${ageMinutes}min old)")
                    return cached.data
                }
            }
        }

        // API 호출
        return withContext(Dispatchers.IO) {
            try {
                val data = api.fetchWidgetData()
                cache.put(cacheKey, CachedData(data, System.currentTimeMillis()))
                data
            } catch (e: Exception) {
                // 캐시 폴백
                cache.get(cacheKey)?.data ?: throw e
            }
        }
    }

    data class CachedData(val data: WidgetData, val timestamp: Long)
}
```

---

### 5.2 네트워크 상태 확인

```kotlin
class NetworkAwareAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE)
            as ConnectivityManager

        val network = connectivityManager.activeNetwork
        val capabilities = connectivityManager.getNetworkCapabilities(network)

        if (capabilities == null ||
            !capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
            // 네트워크 없음
            updateAppWidgetState(context, glanceId) { prefs ->
                prefs[stringPreferencesKey("status")] = "offline"
                prefs[stringPreferencesKey("message")] = "네트워크 연결 없음"
            }
            MyWidget().update(context, glanceId)
            return
        }

        // 네트워크 있음, 데이터 가져오기
        fetchAndUpdateData(context, glanceId)
    }
}
```

---

## 6. 배터리 효율성 베스트 프랙티스

### 6.1 Doze 모드 대응

```kotlin
// WorkManager는 자동으로 Doze 모드 처리
val constraints = Constraints.Builder()
    .setRequiresBatteryNotLow(true) // 배터리 부족 시 실행 안 함
    .setRequiresDeviceIdle(false) // Idle 필요 없음
    .build()

val workRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
    repeatInterval = 30,
    repeatIntervalTimeUnit = TimeUnit.MINUTES
).setConstraints(constraints)
    .setBackoffCriteria(
        BackoffPolicy.EXPONENTIAL,
        WorkRequest.MIN_BACKOFF_MILLIS,
        TimeUnit.MILLISECONDS
    )
    .build()
```

---

### 6.2 절전 모드 감지

```kotlin
class PowerSavingWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
        val isPowerSaveMode = powerManager.isPowerSaveMode

        provideContent {
            Column {
                if (isPowerSaveMode) {
                    Text("절전 모드 - 자동 업데이트 중지")
                    Button("수동 새로고침", onClick = actionRunCallback<ManualRefreshAction>())
                } else {
                    NormalContent()
                }
            }
        }
    }
}
```

**[스크린샷 추천]** 절전 모드 ON/OFF 시 위젯 UI 변화

---

## 7. 종합 베스트 프랙티스 체크리스트

### ✅ 업데이트
- [ ] 사용자 트리거 기반 업데이트 우선
- [ ] 자동 업데이트는 15분 이상 주기
- [ ] 조건부 업데이트 로직 구현 (시간 체크)
- [ ] WorkManager Constraints 활용 (네트워크, 배터리)

### ✅ UI
- [ ] 단순한 레이아웃 (깊이 5 이하)
- [ ] 항목 개수 제한 (10개 이하)
- [ ] 이미지 최적화 (50KB 이하 권장)
- [ ] 조건부 렌더링으로 불필요한 요소 제거

### ✅ 상태
- [ ] 작은 데이터만 저장 (수십 KB 이하)
- [ ] 복잡한 데이터는 Room/File 활용
- [ ] 위젯 삭제 시 데이터 정리
- [ ] 기본값 항상 제공

### ✅ 네트워크
- [ ] 캐싱 전략 구현
- [ ] 네트워크 상태 확인
- [ ] 실패 시 폴백 처리
- [ ] 타임아웃 설정 (10초 이하)

### ✅ 배터리
- [ ] Doze 모드 고려
- [ ] 절전 모드 감지 및 대응
- [ ] 불필요한 wake lock 회피
- [ ] 백그라운드 작업 최소화

---

## 8. 안티 패턴

### ❌ 피해야 할 것들

```kotlin
// 1. 짧은 주기 반복 업데이트
setInterval(1000) { updateWidget() } // 절대 금지!

// 2. 메인 스레드에서 네트워크 호출
provideGlance {
    val data = apiService.fetchData() // 블로킹!
}

// 3. 거대한 상태 저장
prefs[stringPreferencesKey("data")] = 5MBJsonString

// 4. 전역 변수로 상태 관리
companion object {
    var widgetData = ... // 프로세스 종료 시 손실
}

// 5. 무한 재귀 업데이트
class BadAction : ActionCallback {
    override suspend fun onAction(...) {
        updateAppWidgetState(...) { ... }
        MyWidget().update(context, glanceId)
        // 또 다른 Action 트리거 → 무한 루프!
        SomeOtherAction().onAction(...)
    }
}
```

---

## 9. 성능 측정

### 9.1 렌더링 시간 측정

```kotlin
class MeasuredWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        val startTime = System.currentTimeMillis()

        provideContent {
            WidgetContent()
        }

        val renderTime = System.currentTimeMillis() - startTime
        Log.d("Performance", "Render time: ${renderTime}ms")

        // Analytics 전송
        FirebaseAnalytics.getInstance(context).logEvent("widget_render") {
            param("render_time_ms", renderTime)
            param("glance_id", id.toString())
        }
    }
}
```

### 9.2 메모리 사용량 확인

```bash
# 위젯 프로세스 메모리 확인
adb shell dumpsys meminfo <your.package.name>

# 특정 위젯의 DataStore 크기
adb shell ls -lh /data/data/<your.package>/files/datastore/
```

**[스크린샷 추천]** adb meminfo 출력 결과

---

---
