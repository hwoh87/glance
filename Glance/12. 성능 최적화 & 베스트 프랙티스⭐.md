> [!TIP] 🗣️ 핵심내용
배터리 효율적인 위젯 설계와 업데이트 빈도 관리, 메모리 최적화 팁을 공유합니다.
>

## 1. 성능 최적화 개요

Glance 위젯은 홈 화면에 상주하며 시스템 리소스를 지속적으로 사용합니다. 배터리, 메모리, CPU 효율을 고려한 설계가 필수입니다.

```
⚡ 위젯 성능 3대 원칙
1. 업데이트 최소화 (배터리)
2. UI 단순화 (렌더링 비용)
3. 무거운 작업 분리 (Worker/Repository)
```

---

## 2. 업데이트 빈도 최적화

### 2.1 불필요한 업데이트 방지

**❌ 나쁜 예: 과도한 업데이트**
```kotlin
// 1초마다 업데이트 (배터리 소모 심각!)
class BadWidget : GlanceAppWidget() {
    init {
        CoroutineScope(Dispatchers.Main).launch {
            while (true) {
                delay(1000)
                updateAll(context) // 매초 실행!
            }
        }
    }
}
```

**✅ 좋은 예: 필요할 때만 업데이트**
```kotlin
class GoodWidget : GlanceAppWidget() {
    // 사용자 트리거로만 업데이트
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            Column {
                Text("Last update: ${getCurrentTime()}")
                Button(
                    text = "새로고침",
                    onClick = actionRunCallback<RefreshAction>()
                )
            }
        }
    }
}

class RefreshAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 데이터 갱신
        fetchNewData()

        // 상태 업데이트
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[longPreferencesKey("last_update")] = System.currentTimeMillis()
        }

        MyWidget().update(context, glanceId)
    }
}
```

---

### 2.2 주기적 업데이트 전략

**방법 1: PeriodicWorkRequest (권장)**
```kotlin
// 15분마다 업데이트 (최소 주기)
class WidgetUpdateWorker(context: Context, params: WorkerParameters)
    : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        return try {
            // 데이터 갱신
            val data = fetchData()

            // 위젯 상태 업데이트
            val manager = GlanceAppWidgetManager(applicationContext)
            val glanceIds = manager.getGlanceIds(MyWidget::class.java)

            glanceIds.forEach { glanceId ->
                updateAppWidgetState(applicationContext, glanceId) { prefs ->
                    prefs[stringPreferencesKey("data")] = data
                }
            }

            // UI 갱신
            MyWidget().updateAll(applicationContext)

            Result.success()
        } catch (e: Exception) {
            Log.e("WidgetUpdateWorker", "Update failed", e)
            Result.retry()
        }
    }
}

// Worker 등록
fun scheduleWidgetUpdates(context: Context) {
    val updateRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
        repeatInterval = 15, // 최소 15분
        repeatIntervalTimeUnit = TimeUnit.MINUTES
    ).setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true) // 배터리 절약
            .build()
    ).build()

    WorkManager.getInstance(context).enqueueUniquePeriodicWork(
        "widget_update",
        ExistingPeriodicWorkPolicy.KEEP,
        updateRequest
    )
}
```

**[스크린샷 추천]** WorkManager 상태 확인 화면 (adb shell dumpsys jobscheduler)

---

### 2.3 조건부 업데이트

```kotlin
class SmartRefreshAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val prefs = context.dataStoreFile("glance_${glanceId}")
            .let { DataStoreFactory.create(PreferencesSerializer) { it } }
            .data.first()

        val lastUpdate = prefs[longPreferencesKey("last_update")] ?: 0L
        val now = System.currentTimeMillis()

        // 5분 이내 업데이트는 스킵
        if (now - lastUpdate < 5 * 60 * 1000) {
            Log.d("SmartRefresh", "Too soon, skipping update")
            return
        }

        // 실제 업데이트 수행
        updateAppWidgetState(context, glanceId) { mutablePrefs ->
            mutablePrefs[longPreferencesKey("last_update")] = now
            // 데이터 갱신...
        }

        MyWidget().update(context, glanceId)
    }
}
```

---

## 3. UI 렌더링 최적화

### 3.1 단순한 레이아웃 유지

**❌ 복잡한 레이아웃 (느림)**
```kotlin
Column {
    repeat(50) { index ->
        Row {
            Image(ImageProvider(R.drawable.icon))
            Column {
                Text("Item $index")
                Text("Description...")
                Row {
                    Button("A", onClick = {})
                    Button("B", onClick = {})
                    Button("C", onClick = {})
                }
            }
        }
    }
}
```

**✅ 단순한 레이아웃 (빠름)**
```kotlin
Column(modifier = GlanceModifier.fillMaxSize().padding(16.dp)) {
    Text("Title", style = TextStyle(fontSize = 18.sp, fontWeight = FontWeight.Bold))
    Spacer(GlanceModifier.height(8.dp))
    Text("Essential info only")
    Button("Action", onClick = actionRunCallback<MainAction>())
}
```

**[비교 추천]** 복잡한 레이아웃 vs 단순한 레이아웃 렌더링 시간 비교

---

### 3.2 조건부 렌더링 최적화

```kotlin
@Composable
fun OptimizedContent() {
    val prefs = currentState<Preferences>()
    val isExpanded = prefs[booleanPreferencesKey("is_expanded")] ?: false
    val dataCount = prefs[intPreferencesKey("data_count")] ?: 0

    Column {
        Text("Title")

        // 필요할 때만 렌더링
        if (isExpanded && dataCount > 0) {
            HeavyContent(dataCount)
        } else {
            Text("Tap to expand")
        }
    }
}

@Composable
fun HeavyContent(count: Int) {
    // 많은 항목이 있을 때만 표시
    Column {
        repeat(minOf(count, 5)) { index ->
            Text("Item $index")
        }
        if (count > 5) {
            Text("... and ${count - 5} more")
        }
    }
}
```

---

### 3.3 이미지 최적화

```kotlin
// ❌ 큰 이미지 직접 로드
Image(
    provider = ImageProvider(R.drawable.large_image), // 5MB 이미지
    contentDescription = "Large"
)

// ✅ 적절한 크기의 이미지
Image(
    provider = ImageProvider(R.drawable.icon_small), // 50KB 이미지
    contentDescription = "Icon",
    modifier = GlanceModifier.size(48.dp)
)

// ✅ 네트워크 이미지는 캐싱 + 리사이징
suspend fun loadOptimizedImage(url: String, targetSize: Int): Bitmap {
    return imageLoader.execute(
        ImageRequest.Builder(context)
            .data(url)
            .size(targetSize, targetSize)
            .diskCachePolicy(CachePolicy.ENABLED)
            .memoryCachePolicy(CachePolicy.ENABLED)
            .build()
    ).drawable?.toBitmap() ?: createPlaceholder()
}
```

**[스크린샷 추천]** 이미지 크기별 메모리 사용량 비교

---

## 4. 메모리 최적화

### 4.1 상태 크기 최소화

**❌ 불필요한 데이터 저장**
```kotlin
updateAppWidgetState(context, glanceId) { prefs ->
    // 전체 JSON 문자열 저장 (수백 KB)
    prefs[stringPreferencesKey("full_data")] = jsonString

    // 비트맵 직접 저장 (수 MB)
    prefs[stringPreferencesKey("image_base64")] = base64EncodedImage
}
```

**✅ 필요한 데이터만 저장**
```kotlin
updateAppWidgetState(context, glanceId) { prefs ->
    // 필수 필드만 저장
    prefs[stringPreferencesKey("title")] = data.title
    prefs[intPreferencesKey("count")] = data.count
    prefs[longPreferencesKey("timestamp")] = data.timestamp

    // 이미지는 URI/경로만 저장
    prefs[stringPreferencesKey("image_uri")] = data.imageUrl
}

// 복잡한 데이터는 Room에 저장
database.widgetDao().insert(WidgetData(glanceId, fullData))
```

---

### 4.2 데이터 정리

```kotlin
class CleanupWidgetDataWorker(context: Context, params: WorkerParameters)
    : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        val manager = GlanceAppWidgetManager(applicationContext)
        val activeGlanceIds = manager.getGlanceIds(MyWidget::class.java)

        // 모든 저장된 상태 파일 확인
        val dataDir = File(applicationContext.filesDir, "datastore")
        dataDir.listFiles()?.forEach { file ->
            val glanceIdInFile = extractGlanceIdFromFilename(file.name)

            // 활성 위젯이 아니면 삭제
            if (glanceIdInFile !in activeGlanceIds.map { it.toString() }) {
                file.delete()
                Log.d("Cleanup", "Deleted orphaned state: ${file.name}")
            }
        }

        return Result.success()
    }
}

// Receiver에서 삭제 시 정리
override fun onDeleted(context: Context, appWidgetIds: IntArray) {
    super.onDeleted(context, appWidgetIds)

    appWidgetIds.forEach { appWidgetId ->
        val glanceId = GlanceAppWidgetManager(context).getGlanceIdBy(appWidgetId)

        // 상태 파일 삭제
        val file = context.dataStoreFile("glance_${glanceId}")
        file.delete()

        // DB 데이터 삭제
        CoroutineScope(Dispatchers.IO).launch {
            database.widgetDao().deleteByGlanceId(glanceId.toString())
        }
    }
}
```

---

## 5. 네트워크 최적화

### 5.1 효율적인 데이터 페칭

```kotlin
class OptimizedDataRepository {
    private val cache = LruCache<String, CachedData>(maxSize = 10)

    suspend fun fetchData(forceRefresh: Boolean = false): WidgetData {
        val cacheKey = "widget_data"

        // 캐시 확인
        if (!forceRefresh) {
            cache.get(cacheKey)?.let { cached ->
                val ageMinutes = (System.currentTimeMillis() - cached.timestamp) / 60000
                if (ageMinutes < 15) {
                    Log.d("Repository", "Using cached data (${ageMinutes}min old)")
                    return cached.data
                }
            }
        }

        // API 호출
        return withContext(Dispatchers.IO) {
            try {
                val data = api.fetchWidgetData()
                cache.put(cacheKey, CachedData(data, System.currentTimeMillis()))
                data
            } catch (e: Exception) {
                // 캐시 폴백
                cache.get(cacheKey)?.data ?: throw e
            }
        }
    }

    data class CachedData(val data: WidgetData, val timestamp: Long)
}
```

---

### 5.2 네트워크 상태 확인

```kotlin
class NetworkAwareAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE)
            as ConnectivityManager

        val network = connectivityManager.activeNetwork
        val capabilities = connectivityManager.getNetworkCapabilities(network)

        if (capabilities == null ||
            !capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
            // 네트워크 없음
            updateAppWidgetState(context, glanceId) { prefs ->
                prefs[stringPreferencesKey("status")] = "offline"
                prefs[stringPreferencesKey("message")] = "네트워크 연결 없음"
            }
            MyWidget().update(context, glanceId)
            return
        }

        // 네트워크 있음, 데이터 가져오기
        fetchAndUpdateData(context, glanceId)
    }
}
```

---

## 6. 배터리 효율성 베스트 프랙티스

### 6.1 Doze 모드 대응

```kotlin
// WorkManager는 자동으로 Doze 모드 처리
val constraints = Constraints.Builder()
    .setRequiresBatteryNotLow(true) // 배터리 부족 시 실행 안 함
    .setRequiresDeviceIdle(false) // Idle 필요 없음
    .build()

val workRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
    repeatInterval = 30,
    repeatIntervalTimeUnit = TimeUnit.MINUTES
).setConstraints(constraints)
    .setBackoffCriteria(
        BackoffPolicy.EXPONENTIAL,
        WorkRequest.MIN_BACKOFF_MILLIS,
        TimeUnit.MILLISECONDS
    )
    .build()
```

---

### 6.2 절전 모드 감지

```kotlin
class PowerSavingWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
        val isPowerSaveMode = powerManager.isPowerSaveMode

        provideContent {
            Column {
                if (isPowerSaveMode) {
                    Text("절전 모드 - 자동 업데이트 중지")
                    Button("수동 새로고침", onClick = actionRunCallback<ManualRefreshAction>())
                } else {
                    NormalContent()
                }
            }
        }
    }
}
```

**[스크린샷 추천]** 절전 모드 ON/OFF 시 위젯 UI 변화

---

## 7. 종합 베스트 프랙티스 체크리스트

### ✅ 업데이트
- [ ] 사용자 트리거 기반 업데이트 우선
- [ ] 자동 업데이트는 15분 이상 주기
- [ ] 조건부 업데이트 로직 구현 (시간 체크)
- [ ] WorkManager Constraints 활용 (네트워크, 배터리)

### ✅ UI
- [ ] 단순한 레이아웃 (깊이 5 이하)
- [ ] 항목 개수 제한 (10개 이하)
- [ ] 이미지 최적화 (50KB 이하 권장)
- [ ] 조건부 렌더링으로 불필요한 요소 제거

### ✅ 상태
- [ ] 작은 데이터만 저장 (수십 KB 이하)
- [ ] 복잡한 데이터는 Room/File 활용
- [ ] 위젯 삭제 시 데이터 정리
- [ ] 기본값 항상 제공

### ✅ 네트워크
- [ ] 캐싱 전략 구현
- [ ] 네트워크 상태 확인
- [ ] 실패 시 폴백 처리
- [ ] 타임아웃 설정 (10초 이하)

### ✅ 배터리
- [ ] Doze 모드 고려
- [ ] 절전 모드 감지 및 대응
- [ ] 불필요한 wake lock 회피
- [ ] 백그라운드 작업 최소화

---

## 8. 안티 패턴

이 섹션에서는 흔히 발생하는 안티패턴과 올바른 해결책을 제시합니다.

### 8.1 과도한 업데이트 주기

**❌ 안티패턴: 짧은 주기로 반복 업데이트**
```kotlin
// 1초마다 위젯 업데이트 - 배터리 소모 심각!
setInterval(1000) {
    updateWidget()
}

// 또는
CoroutineScope(Dispatchers.Main).launch {
    while (true) {
        delay(1000)
        MyWidget().updateAll(context)
    }
}
```

**✅ 권장: 사용자 트리거 + WorkManager 조합**
```kotlin
// 사용자 트리거 방식
Button(
    text = "새로고침",
    onClick = actionRunCallback<RefreshAction>()
)

// 자동 업데이트는 WorkManager로 (최소 15분)
val workRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
    repeatInterval = 15,
    repeatIntervalTimeUnit = TimeUnit.MINUTES
).setConstraints(
    Constraints.Builder()
        .setRequiredNetworkType(NetworkType.CONNECTED)
        .setRequiresBatteryNotLow(true)
        .build()
).build()
```

---

### 8.2 provideContent에서 네트워크/I/O 호출 (🔴 CRITICAL)

#### 8.2.1 왜 provideContent에서 네트워크/I/O를 하면 안 되나요?

> [!DANGER] RemoteViews 변환 구간의 특성
> `provideContent { }`는 **"RemoteViews로 변환될 UI 트리만 선언"**하는 단계입니다.
>
> **1. Compose 런타임 부재**
> - `remember`, `LaunchedEffect`, 코루틴 컨텍스트 등 Compose 런타임 기능이 동작하지 않습니다.
> - UI 선언 중에 블로킹/I/O가 끼면 **렌더링 실패 또는 지연**이 발생합니다.
>
> **2. 프로세스 제약**
> - 위젯은 **런처 프로세스와 IPC로 그려지는** 별도 프로세스/스레드 환경입니다.
> - 이 환경에서 네트워크/DB 호출은 **안정적이지 않고**, ANR(Application Not Responding) 위험이 있습니다.
>
> **3. 생명주기 문제**
> - `provideContent`는 UI를 빠르게 구성해야 하는 동기적 단계입니다.
> - 네트워크 지연(수 초)이 발생하면 사용자는 빈 화면만 보게 됩니다.

#### 8.2.2 자주 하는 실수

**❌ 안티패턴 1: runBlocking으로 네트워크 호출**
```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        // ❌ ANR 위험! UI 렌더링 중 네트워크 대기
        val data = runBlocking {
            apiService.fetchData() // 수 초 대기...
        }
        Text(data.title)
    }
}
```

**❌ 안티패턴 2: provideGlance 외부에서 네트워크 호출**
```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    // ❌ 여기서도 안 됨! provideGlance는 빠르게 끝나야 함
    val data = withContext(Dispatchers.IO) {
        apiService.fetchData() // 렌더링 지연
    }

    provideContent {
        Text(data.title)
    }
}
```

**❌ 안티패턴 3: 상태 저장 없이 update()만 반복**
```kotlin
class BadAction : ActionCallback {
    override suspend fun onAction(...) {
        // ❌ 데이터를 DataStore에 저장하지 않음!
        val data = fetchData()

        // UI만 갱신 - 다음 provideGlance에서 data 없음
        MyWidget().update(context, glanceId)
    }
}
```

**❌ 안티패턴 4: 인스턴스 여러 개인데 한 개만 갱신**
```kotlin
// ❌ 위젯이 3개인데 첫 번째 것만 업데이트
val glanceIds = manager.getGlanceIds(MyWidget::class.java)
val firstId = glanceIds.firstOrNull() ?: return

updateAppWidgetState(context, firstId) { prefs ->
    prefs[dataKey] = newData
}
MyWidget().update(context, firstId) // 나머지 위젯은 업데이트 안 됨!
```

#### 8.2.3 올바른 패턴

**✅ 올바른 예: Worker에서 준비 → DataStore 저장 → UI는 읽기만**

```kotlin
// 1. Worker에서 데이터 가져오기
class DataFetchWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        return try {
            // 네트워크/DB에서 데이터 가져오기 (무거운 I/O)
            val data = withContext(Dispatchers.IO) {
                apiService.fetchData()
            }

            // 모든 위젯 인스턴스의 상태 업데이트
            val manager = GlanceAppWidgetManager(applicationContext)
            val glanceIds = manager.getGlanceIds(MyWidget::class.java)

            glanceIds.forEach { glanceId ->
                updateAppWidgetState(applicationContext, glanceId) { prefs ->
                    prefs[stringPreferencesKey("title")] = data.title
                    prefs[stringPreferencesKey("description")] = data.description
                    prefs[longPreferencesKey("timestamp")] = System.currentTimeMillis()
                }
            }

            // 모든 위젯 UI 갱신
            MyWidget().updateAll(applicationContext)
            Result.success()

        } catch (e: Exception) {
            Log.e("DataFetchWorker", "Fetch failed", e)
            Result.retry()
        }
    }
}

// 2. ActionCallback에서 Worker 트리거
class RefreshDataAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 즉시 로딩 상태로 변경 (사용자 피드백)
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[booleanPreferencesKey("is_loading")] = true
        }
        MyWidget().update(context, glanceId)

        // Worker로 백그라운드 작업 위임
        val workRequest = OneTimeWorkRequestBuilder<DataFetchWorker>()
            .setInputData(workDataOf("glance_id" to glanceId.toString()))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)
    }
}

// 3. 위젯은 currentState()로 읽기만
override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        val prefs = currentState<Preferences>()
        val title = prefs[stringPreferencesKey("title")] ?: "데이터 없음"
        val isLoading = prefs[booleanPreferencesKey("is_loading")] ?: false

        Column(modifier = GlanceModifier.fillMaxSize().padding(16.dp)) {
            if (isLoading) {
                CircularProgressIndicator()
                Text("로딩 중...")
            } else {
                Text(title)
                Button("새로고침", onClick = actionRunCallback<RefreshDataAction>())
            }
        }
    }
}
```

#### 8.2.4 핵심 원칙 정리

> [!NOTE] 💬 발표 설명
> "**provideContent의 3대 원칙**을 꼭 기억하세요.
>
> 1. **UI 선언만**: RemoteViews로 변환될 UI 트리만 선언합니다. 부수효과(네트워크, DB, 파일 I/O) 금지.
> 2. **상태는 읽기만**: `currentState<Preferences>()`로 DataStore에서 읽기만 합니다. 쓰기는 ActionCallback/Worker에서.
> 3. **빠른 실행**: provideContent는 밀리초 단위로 끝나야 합니다. 수 초 걸리는 작업은 절대 금지.
>
> **잘못된 흐름**:
> ```
> 사용자 클릭 → ActionCallback → provideContent에서 네트워크 호출 → ANR
> ```
>
> **올바른 흐름**:
> ```
> 사용자 클릭 → ActionCallback → 로딩 상태 저장 → update() (즉시 피드백)
>              → Worker enqueue → 백그라운드에서 데이터 로드
>              → DataStore 저장 → update() (결과 반영)
> ```
>
> 이렇게 하면 **UI는 절대 블로킹되지 않고**, 사용자는 명확한 피드백을 받습니다."

**자세한 내용은 → [4. GlanceAppWidget⭐⭐](4.%20GlanceAppWidget⭐⭐.md) 섹션 3.4** 참고

---

### 8.3 비효율적인 상태 저장

**❌ 안티패턴: 거대한 데이터를 Preferences에 저장**
```kotlin
updateAppWidgetState(context, glanceId) { prefs ->
    // 5MB JSON 문자열을 DataStore에 저장
    prefs[stringPreferencesKey("data")] = largeJsonString

    // 또는 Base64 인코딩된 이미지
    prefs[stringPreferencesKey("image")] = base64EncodedBitmap
}
```

**✅ 권장: 필요한 데이터만 저장, 큰 데이터는 Room/File 활용**
```kotlin
// Preferences에는 작은 데이터만
updateAppWidgetState(context, glanceId) { prefs ->
    prefs[stringPreferencesKey("title")] = data.title
    prefs[intPreferencesKey("count")] = data.count
    prefs[stringPreferencesKey("image_uri")] = imageUri.toString()
}

// 복잡한 데이터는 Room에 저장
database.widgetDao().insert(WidgetData(
    glanceId = glanceId.toString(),
    fullData = complexData
))
```

---

### 8.4 불안정한 상태 관리

**❌ 안티패턴: 전역 변수나 static으로 상태 관리**
```kotlin
companion object {
    var widgetData: WidgetData? = null // 프로세스 종료 시 손실!
}

override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        Text(widgetData?.title ?: "Empty")
    }
}
```

**✅ 권장: DataStore 기반 상태 관리**
```kotlin
// 상태는 반드시 DataStore에 저장
updateAppWidgetState(context, glanceId) { prefs ->
    prefs[stringPreferencesKey("title")] = newTitle
}

// 위젯에서 읽기
override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        val prefs = currentState<Preferences>()
        val title = prefs[stringPreferencesKey("title")] ?: "Default"
        Text(title)
    }
}
```

---

### 8.5 순환 업데이트

**❌ 안티패턴: Action에서 다른 Action 트리거 → 무한 루프**
```kotlin
class BadAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        updateAppWidgetState(context, glanceId) { ... }
        MyWidget().update(context, glanceId)

        // 또 다른 Action 트리거 - 무한 루프 위험!
        AnotherAction().onAction(context, glanceId, parameters)
    }
}
```

**✅ 권장: Action은 단일 책임, 체이닝 금지**
```kotlin
class GoodAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 자신의 작업만 수행
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[stringPreferencesKey("status")] = "completed"
        }

        // 2. UI 업데이트
        MyWidget().update(context, glanceId)

        // 3. 다른 작업이 필요하면 WorkManager로
        if (needsBackgroundWork) {
            val workRequest = OneTimeWorkRequestBuilder<CleanupWorker>().build()
            WorkManager.getInstance(context).enqueue(workRequest)
        }
    }
}
```

---

## 9. 성능 측정

### 9.1 렌더링 시간 측정

```kotlin
class MeasuredWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        val startTime = System.currentTimeMillis()

        provideContent {
            WidgetContent()
        }

        val renderTime = System.currentTimeMillis() - startTime
        Log.d("Performance", "Render time: ${renderTime}ms")

        // Analytics 전송
        FirebaseAnalytics.getInstance(context).logEvent("widget_render") {
            param("render_time_ms", renderTime)
            param("glance_id", id.toString())
        }
    }
}
```

### 9.2 메모리 사용량 확인

```bash
# 위젯 프로세스 메모리 확인
adb shell dumpsys meminfo <your.package.name>

# 특정 위젯의 DataStore 크기
adb shell ls -lh /data/data/<your.package>/files/datastore/
```

**[스크린샷 추천]** adb meminfo 출력 결과

---

---
