> [!TIP] 🗣️ 핵심내용
위젯이 생성, 업데이트, 삭제되는 과정과 수동/자동 업데이트 방법을 이해합니다.
>

## 1. 위젯 생명주기 개요

Glance 위젯은 Android 시스템과 상호작용하며 다음과 같은 생명주기를 가집니다.

```
📱 위젯 생명주기
┌─────────────────────────────────────┐
│  사용자가 홈 화면에 위젯 추가        │
└──────────────┬──────────────────────┘
               ▼
    ┌──────────────────────┐
    │   onEnabled()        │ ← 첫 번째 위젯 인스턴스 추가 시 1회
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │   onUpdate()         │ ← 각 위젯 인스턴스마다 호출
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │ provideGlance()      │ ← UI 생성
    └──────────┬───────────┘
               ▼
         [위젯 표시]
               │
    ┌──────────▼───────────┐
    │  사용자 인터랙션         │
    │  - 버튼 클릭           │
    │  - 리사이즈            │
    │  - 설정 변경           │
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │   update()           │ ← 수동 업데이트
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │ provideGlance()      │ ← UI 재생성
    └──────────────────────┘
               │
    ┌──────────▼───────────┐
    │ 사용자가 위젯 삭제       │
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │   onDeleted()        │ ← 각 위젯 삭제 시
    └──────────┬───────────┘
               ▼
    ┌──────────────────────┐
    │   onDisabled()       │ ← 마지막 위젯 삭제 시 1회
    └──────────────────────┘
```

> [!NOTE] 💬 발표 설명
> "위젯 생명주기를 이해하는 게 중요합니다. 플로우차트를 보면 전체 흐름이 보입니다.
>
> **최초 추가**: 사용자가 위젯을 처음 추가하면 `onEnabled()` → `onUpdate()` → `provideGlance()` 순서로 호출됩니다. `onEnabled`는 딱 한 번만 호출되고, 이때 WorkManager 같은 전역 리소스를 설정합니다.
>
> **업데이트**: 이후 업데이트는 `update()` → `provideGlance()` 흐름입니다. 상태를 변경하고 `update()`를 호출하면 `provideGlance`가 다시 실행되면서 UI가 새로 그려집니다.
>
> **삭제**: 위젯을 삭제하면 `onDeleted()`가 호출되고, 마지막 위젯이 삭제되면 `onDisabled()`가 호출됩니다. 여기서 WorkManager를 취소하거나 상태 파일을 정리합니다.
>
> 핵심은 **onEnabled/onDisabled는 전역 리소스**, **onDeleted는 인스턴스별 정리**라는 점입니다."

---

## 2. Receiver 생명주기 콜백

### 2.1 onEnabled()

**첫 번째 위젯 인스턴스가 추가될 때 1회만 호출**됩니다.

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    override val glanceAppWidget: GlanceAppWidget = MyWidget()

    override fun onEnabled(context: Context) {
        super.onEnabled(context)
        Log.d("WidgetLifecycle", "첫 위젯 추가됨")

        // 전역 초기화 작업
        // - WorkManager 예약
        // - 데이터베이스 초기화
        // - 리소스 준비
        schedulePeriodicUpdates(context)
    }

    private fun schedulePeriodicUpdates(context: Context) {
        val updateRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
            repeatInterval = 30,
            repeatIntervalTimeUnit = TimeUnit.MINUTES
        ).build()

        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            "widget_update",
            ExistingPeriodicWorkPolicy.KEEP,
            updateRequest
        )
    }
}
```

**[스크린샷 추천]** 첫 위젯 추가 시 onEnabled() 로그 출력

---

### 2.2 onUpdate()

**위젯이 업데이트되어야 할 때 호출**됩니다.

**호출 시점**:
- 위젯 처음 추가될 때
- updatePeriodMillis 주기 도래 시 (30분 이상, 신뢰도 낮음)
- 시스템 재부팅 후
- 수동으로 `AppWidgetManager.updateAppWidget()` 호출 시

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    override val glanceAppWidget: GlanceAppWidget = MyWidget()

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        super.onUpdate(context, appWidgetManager, appWidgetIds)
        Log.d("WidgetLifecycle", "onUpdate called for ${appWidgetIds.size} widgets")

        // 각 위젯 인스턴스 초기화
        appWidgetIds.forEach { appWidgetId ->
            val glanceId = GlanceAppWidgetManager(context).getGlanceIdBy(appWidgetId)

            CoroutineScope(Dispatchers.IO).launch {
                // 초기 상태 설정
                updateAppWidgetState(context, glanceId) { prefs ->
                    prefs[longPreferencesKey("created_at")] = System.currentTimeMillis()
                    prefs[intPreferencesKey("count")] = 0
                }

                // UI 갱신
                MyWidget().update(context, glanceId)
            }
        }
    }
}
```

---

### 2.3 onDeleted()

**위젯 인스턴스가 삭제될 때 호출**됩니다.

```kotlin
override fun onDeleted(context: Context, appWidgetIds: IntArray) {
    super.onDeleted(context, appWidgetIds)
    Log.d("WidgetLifecycle", "위젯 삭제: ${appWidgetIds.size}개")

    appWidgetIds.forEach { appWidgetId ->
        val glanceId = GlanceAppWidgetManager(context).getGlanceIdBy(appWidgetId)

        CoroutineScope(Dispatchers.IO).launch {
            // 1. 상태 파일 삭제
            val stateFile = context.dataStoreFile("glance_$glanceId")
            if (stateFile.exists()) {
                stateFile.delete()
                Log.d("WidgetLifecycle", "상태 파일 삭제: $glanceId")
            }

            // 2. 데이터베이스 정리
            database.widgetDao().deleteByGlanceId(glanceId.toString())

            // 3. 캐시 정리
            clearWidgetCache(glanceId)
        }
    }
}
```

---

### 2.4 onDisabled()

**마지막 위젯 인스턴스가 삭제될 때 1회만 호출**됩니다.

```kotlin
override fun onDisabled(context: Context) {
    super.onDisabled(context)
    Log.d("WidgetLifecycle", "마지막 위젯 삭제됨")

    // 전역 정리 작업
    // - WorkManager 취소
    // - 리소스 해제
    // - 알림 취소
    WorkManager.getInstance(context).cancelUniqueWork("widget_update")
}
```

---

## 3. 업데이트 트리거 방법

### 3.1 수동 업데이트: update() / updateAll()

#### 3.1.1 단일 위젯 업데이트

```kotlin
class RefreshAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 데이터 가져오기
        val newData = fetchDataFromApi()

        // 2. 상태 업데이트
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[stringPreferencesKey("data")] = newData
            prefs[longPreferencesKey("last_update")] = System.currentTimeMillis()
        }

        // 3. UI 갱신 (필수!)
        MyWidget().update(context, glanceId)
    }
}
```

#### 3.1.2 모든 위젯 인스턴스 업데이트

```kotlin
class RefreshAllAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        val manager = GlanceAppWidgetManager(context)
        val glanceIds = manager.getGlanceIds(MyWidget::class.java)

        glanceIds.forEach { id ->
            updateAppWidgetState(context, id) { prefs ->
                prefs[longPreferencesKey("sync_time")] = System.currentTimeMillis()
            }
        }

        // 모든 위젯 한 번에 갱신
        MyWidget().updateAll(context)
    }
}
```

**[비디오 추천]** 버튼 클릭 → update() 호출 → 위젯 UI 즉시 변경

---

### 3.2 WorkManager를 통한 주기적 업데이트 (권장)

#### 3.2.1 Worker 구현

```kotlin
class WidgetUpdateWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        Log.d("WidgetUpdateWorker", "주기적 업데이트 시작")

        return try {
            // 1. 데이터 가져오기
            val data = fetchDataFromServer()

            // 2. 모든 위젯 업데이트
            val manager = GlanceAppWidgetManager(applicationContext)
            val glanceIds = manager.getGlanceIds(MyWidget::class.java)

            glanceIds.forEach { glanceId ->
                updateAppWidgetState(applicationContext, glanceId) { prefs ->
                    prefs[stringPreferencesKey("server_data")] = data
                    prefs[longPreferencesKey("last_sync")] = System.currentTimeMillis()
                }
            }

            // 3. UI 갱신
            MyWidget().updateAll(applicationContext)

            Log.d("WidgetUpdateWorker", "업데이트 성공")
            Result.success()
        } catch (e: Exception) {
            Log.e("WidgetUpdateWorker", "업데이트 실패", e)
            Result.retry()
        }
    }
}
```

#### 3.2.2 Worker 예약 (onEnabled에서)

```kotlin
private fun schedulePeriodicUpdates(context: Context) {
    val constraints = Constraints.Builder()
        .setRequiredNetworkType(NetworkType.CONNECTED)  // 네트워크 필요
        .setRequiresBatteryNotLow(true)                // 배터리 충분할 때만
        .build()

    val updateRequest = PeriodicWorkRequestBuilder<WidgetUpdateWorker>(
        repeatInterval = 30,  // 최소 15분
        repeatIntervalTimeUnit = TimeUnit.MINUTES
    )
        .setConstraints(constraints)
        .setBackoffCriteria(
            BackoffPolicy.EXPONENTIAL,
            WorkRequest.MIN_BACKOFF_MILLIS,
            TimeUnit.MILLISECONDS
        )
        .build()

    WorkManager.getInstance(context).enqueueUniquePeriodicWork(
        "widget_periodic_update",
        ExistingPeriodicWorkPolicy.KEEP,  // 기존 작업 유지
        updateRequest
    )
}
```

**[스크린샷 추천]** WorkManager 스케줄 확인 (adb shell dumpsys jobscheduler)

---


## 4. 시스템 이벤트에 따른 업데이트

### 4.1 화면 크기 변경 (리사이즈)

```kotlin
override fun onAppWidgetOptionsChanged(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int,
    newOptions: Bundle
) {
    super.onAppWidgetOptionsChanged(context, appWidgetManager, appWidgetId, newOptions)

    val glanceId = GlanceAppWidgetManager(context).getGlanceIdBy(appWidgetId)

    // 새 크기 정보
    val minWidth = newOptions.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH)
    val minHeight = newOptions.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT)
    val maxWidth = newOptions.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH)
    val maxHeight = newOptions.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT)

    Log.d("WidgetResize", "Size changed: ${minWidth}x${minHeight}")

    CoroutineScope(Dispatchers.IO).launch {
        // provideGlance()가 자동으로 재호출되어 LocalSize.current로 새 크기 반영
        MyWidget().update(context, glanceId)
    }
}
```

---

### 4.2 재부팅 후 복원

```xml
<!-- AndroidManifest.xml -->
<receiver
    android:name=".BootCompletedReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
    </intent-filter>
</receiver>
```

```kotlin
class BootCompletedReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            // WorkManager 재등록
            schedulePeriodicUpdates(context)

            // 모든 위젯 즉시 업데이트
            CoroutineScope(Dispatchers.IO).launch {
                MyWidget().updateAll(context)
            }
        }
    }
}
```

---

## 5. 업데이트 전략 비교

| 방법 | 최소 주기 | 정확도 | 배터리 효율 | 권장 용도 |
|------|----------|--------|------------|-----------|
| **update()** | 즉시 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 사용자 인터랙션 |
| **WorkManager** | 15분 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 주기적 데이터 동기화 (권장) |
| **updatePeriodMillis** | 30분 | ⭐ | ⭐⭐⭐ | 사용 비권장 (신뢰도 낮음) |

---

## 6. 베스트 프랙티스

### ✅ DO
- 사용자 트리거 기반 업데이트 우선 (버튼 클릭)
- WorkManager로 15분 이상 주기 설정
- 상태 변경 후 반드시 `update()` 호출
- 배터리/네트워크 Constraints 활용
- onDeleted()에서 리소스 정리

### ❌ DON'T
- 1분 미만 빈번한 자동 업데이트
- updatePeriodMillis에 의존 (신뢰도 낮음)
- 상태만 변경하고 update() 생략
- 무거운 작업을 onUpdate()에서 직접 실행
- 위젯 삭제 시 데이터 미정리

---

## 7. 디버깅 팁

### 7.1 생명주기 로깅

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    override val glanceAppWidget: GlanceAppWidget = MyWidget()

    override fun onEnabled(context: Context) {
        super.onEnabled(context)
        Log.d("WidgetLifecycle", "✅ onEnabled")
    }

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        super.onUpdate(context, appWidgetManager, appWidgetIds)
        Log.d("WidgetLifecycle", "🔄 onUpdate: ${appWidgetIds.joinToString()}")
    }

    override fun onDeleted(context: Context, appWidgetIds: IntArray) {
        super.onDeleted(context, appWidgetIds)
        Log.d("WidgetLifecycle", "❌ onDeleted: ${appWidgetIds.joinToString()}")
    }

    override fun onDisabled(context: Context) {
        super.onDisabled(context)
        Log.d("WidgetLifecycle", "🚫 onDisabled")
    }
}
```

### 7.2 강제 업데이트 (디버그용)

```kotlin
class ForceUpdateAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        Log.d("ForceUpdate", "Forcing update for $glanceId")
        MyWidget().update(context, glanceId)
    }
}
```

**[스크린샷 추천]** Logcat에서 생명주기 로그 필터링

---

---
