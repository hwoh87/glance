> [!TIP] 🗣️ 핵심내용
위젯의 상태를 저장하고 복원하는 방법. `currentState()`, `updateAll()`, `update()`를 활용한 데이터 관리를 배웁니다.
>

## 1. State 관리 개요

Glance 위젯은 **인스턴스별로 독립적인 상태**를 가질 수 있습니다. 홈 화면에 같은 위젯을 여러 개 추가하면 각각 다른 데이터를 보여줄 수 있다는 의미입니다.

```
📱 홈 화면
   ├─ 위젯 A (`GlanceId`: 123) → State A
   ├─ 위젯 B (`GlanceId`: 456) → State B
   └─ 위젯 C (`GlanceId`: 789) → State C
```

### 1.1 전통 위젯과의 상태 관리 비교

**전통 위젯 (SharedPreferences 직접 구현)**
```kotlin
class TraditionalWidget : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        appWidgetIds.forEach { appWidgetId ->
            // 1. SharedPreferences에서 수동으로 상태 읽기
            val prefs = context.getSharedPreferences("widget_$appWidgetId", Context.MODE_PRIVATE)
            val count = prefs.getInt("count", 0)
            val name = prefs.getString("name", "Guest") ?: "Guest"

            // 2. RemoteViews 생성 및 설정
            val views = RemoteViews(context.packageName, R.layout.widget_layout)
            views.setTextViewText(R.id.count_text, "Count: $count")
            views.setTextViewText(R.id.name_text, "Name: $name")

            // 3. 버튼 클릭 시 BroadcastReceiver로 전달
            val intent = Intent(context, IncrementReceiver::class.java)
            intent.putExtra("widget_id", appWidgetId)
            val pendingIntent = PendingIntent.getBroadcast(
                context, appWidgetId, intent, PendingIntent.FLAG_UPDATE_CURRENT
            )
            views.setOnClickPendingIntent(R.id.increment_button, pendingIntent)

            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}

// 별도 BroadcastReceiver로 상태 변경 처리
class IncrementReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val widgetId = intent.getIntExtra("widget_id", -1)

        // 1. SharedPreferences에서 읽기
        val prefs = context.getSharedPreferences("widget_$widgetId", Context.MODE_PRIVATE)
        val currentCount = prefs.getInt("count", 0)

        // 2. 상태 변경
        prefs.edit().putInt("count", currentCount + 1).apply()

        // 3. 위젯 수동 업데이트
        val appWidgetManager = AppWidgetManager.getInstance(context)
        val views = RemoteViews(context.packageName, R.layout.widget_layout)
        views.setTextViewText(R.id.count_text, "Count: ${currentCount + 1}")
        appWidgetManager.updateAppWidget(widgetId, views)
    }
}
```

**문제점**:
- SharedPreferences 파일명 관리 (`widget_$appWidgetId`)를 직접 해야 함
- 상태 읽기/쓰기 로직이 여러 곳에 분산 (AppWidgetProvider, BroadcastReceiver 등)
- 인스턴스별 상태 분리를 수동으로 구현해야 함
- 타입 안정성 부족 (문자열 키 사용)
- 상태 변경 후 UI 업데이트를 수동으로 처리

> [!NOTE] PendingIntent를 쓰는 이유
전통적인 위젯의 UI는 앱 내부에서 실행되는 뷰가 아니라 **런처 프로세스가 그리는 RemoteViews 복제본**입니다.
> 그래서 버튼 클릭 같은 이벤트를 직접 받을 수 없고, **“명령 전달” 방식으로만 처리**해야 합니다.
> 즉, setOnClickPendingIntent()로 런처에 “이 버튼이 눌리면 PendingIntent를 실행하라”는 지시를 보내고,
> 런처가 클릭 시 BroadcastReceiver나 Activity를 호출하는 구조입니다.

**Glance 위젯 (DataStore 기반 StateDefinition)**
```kotlin
class ModernWidget : GlanceAppWidget() {
    // StateDefinition 지정만으로 상태 관리 준비 완료
    override val stateDefinition = PreferencesGlanceStateDefinition

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // 1. 상태 읽기 - 인스턴스별 자동 분리
            val prefs = currentState<Preferences>()
            val count = prefs[intPreferencesKey("count")] ?: 0
            val name = prefs[stringPreferencesKey("name")] ?: "Guest"

            Column {
                Text("Count: $count")
                Text("Name: $name")

                // 2. 버튼 클릭 시 ActionCallback으로 처리
                Button(
                    text = "Increment",
                    onClick = actionRunCallback<IncrementAction>()
                )
            }
        }
    }
}

// 상태 변경 로직 - 타입 안정성 보장
class IncrementAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 상태 변경 - 인스턴스별 자동 관리
        updateAppWidgetState(context, glanceId) { prefs ->
            val current = prefs[intPreferencesKey("count")] ?: 0
            prefs[intPreferencesKey("count")] = current + 1
        }

        // 2. UI 업데이트 - 한 줄로 처리
        ModernWidget().update(context, glanceId)
    }
}
```

**개선점**:
- **인스턴스별 상태 자동 관리**: GlanceId 기반으로 자동 분리
- **DataStore 기반**: SharedPreferences보다 안전하고 비동기 친화적
- **타입 안정성**: `intPreferencesKey`, `stringPreferencesKey` 등으로 타입 보장
- **중앙화된 로직**: 상태 관리가 `updateAppWidgetState` + `update()`로 통일
- **코드 간결성**: 보일러플레이트 대폭 감소

> [!NOTE] 💡 예제 1의 초점
> 이 예제는 **전통 위젯 대비 Glance의 개선점**을 강조합니다:
> - 자동 인스턴스 분리 (GlanceId 기반)
> - 타입 안전한 상태 관리 (Typed Key)
> - 간결한 코드 (ActionCallback 한 곳에 집중)


**비교 요약**:

| 항목 | 전통 위젯 | Glance 위젯 |
|------|-----------|-------------|
| **상태 저장소** | SharedPreferences (직접 구현) | DataStore (자동 제공) |
| **인스턴스 분리** | `widget_$appWidgetId` 파일명 수동 관리 | `GlanceId` 자동 관리 |
| **타입 안정성** | 문자열 키 (타입 불안정) | Typed Key (타입 안정) |
| **상태 변경 흐름** | 읽기 → 변경 → 저장 → UI 업데이트 (4단계) | `updateAppWidgetState` + `update()` (2단계) |
| **코드 분산** | AppWidgetProvider, BroadcastReceiver 등 여러 곳 | ActionCallback 한 곳에 집중 |
| **비동기 지원** | 수동 구현 필요 | Coroutine 기반 자동 지원 |

---

### 1.2 타입 안정성: SharedPreferences vs DataStore

Glance DataStore의 **Typed Key 시스템**은 전통 위젯의 SharedPreferences 문자열 키 방식과 비교했을 때 **타입 안정성 측면에서 큰 차이**가 있습니다.

**핵심 차이점**:

```kotlin
// ❌ SharedPreferences - 문자열 키 (타입 불안정)
prefs.edit().putInt("count", 42).apply()
val count = prefs.getString("count", "0") // 런타임 크래시! ClassCastException

// ✅ Glance DataStore - Typed Key (타입 안정)
val countKey = intPreferencesKey("count")
prefs[countKey] = 42 // ✅
prefs[countKey] = "text" // ❌ 컴파일 에러! Type mismatch
```

**타입 안정성의 핵심 가치**:
- **컴파일 타임 타입 체크**: 타입 불일치를 코드 작성 단계에서 발견
- **오타 방지**: IDE 자동완성으로 키 이름 실수 원천 차단
- **안전한 리팩토링**: Refactor > Rename으로 모든 사용처 자동 변경
- **협업 안전성**: 여러 개발자가 같은 키를 다른 타입으로 사용하는 것을 컴파일러가 방지

> [!TIP] 📚 상세 문서
> 타입 안정성에 대한 **심층 분석**(6가지 문제점, 6가지 해결책, 실전 예제, 비교표)은 별도 문서에서 확인하세요:
>
> **[[6.1. 타입 안정성 상세 비교⭐]]**

**비교 요약**:

| 측면         | 전통 위젯 (SharedPreferences)  | Glance 위젯 (DataStore)        |
| ---------- | -------------------------- | ---------------------------- |
| **키 타입**   | String (타입 없음)             | `Preferences.Key<T>` (타입 있음) |
| **타입 체크**  | 런타임                        | 컴파일 타임                       |
| **오타 감지**  | ❌ 불가능 (0/null 반환)          | ✅ 가능 (컴파일 에러)                |
| **타입 불일치** | ❌ ClassCastException (크래시) | ✅ 컴파일 에러 (사전 방지)             |
| **자동완성**   | ❌ 없음                       | ✅ 완벽 지원                      |
| **리팩토링**   | ❌ 수동 검색 필요                 | ✅ IDE Refactor 가능            |
| **협업 안전성** | ❌ 낮음 (문자열 충돌)              | ✅ 높음 (컴파일 보장)                |

---

## 2. `StateDefinition` 종류

### 2.1 `PreferencesGlanceStateDefinition` (가장 많이 사용)
- **간단한 key-value 데이터**에 적합
- DataStore Preferences 기반
- 타입: `Int`, `String`, `Boolean`, `Long`, `Float`, `Double`, `Set<String>`

```kotlin
class SimpleWidget : GlanceAppWidget() {
    // StateDefinition 지정
    override val stateDefinition = PreferencesGlanceStateDefinition

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // 1. 현재 상태 읽기
            val prefs = currentState<Preferences>()
            val count = prefs[intPreferencesKey("count")] ?: 0
            val name = prefs[stringPreferencesKey("name")] ?: "Guest"
            val isActive = prefs[booleanPreferencesKey("is_active")] ?: false

            Column {
                Text("Count: $count")
                Text("Name: $name")
                Text("Active: $isActive")
            }
        }
    }
}
```

---

### 2.2 `ProtoGlanceStateDefinition` (복잡한 데이터)
- **구조화된 데이터**에 적합
- Protocol Buffers 사용
- 타입 안정성 ↑, 직렬화 성능 ↑

** Proto 에 대한 자세한 내용은 → [[6.2 Proto StateDefinition]]** 참고

---

## 3. 상태 읽기

### 3.1 currentState()
```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        // Preferences 방식
        val prefs = currentState<Preferences>()
        val value = prefs[intPreferencesKey("my_key")] ?: 0

        // Proto 방식
        val state = currentState<WidgetState>()
        val title = state.title

        Text("Value: $value, Title: $title")
    }
}
```

> [!NOTE] 
> "`currentState()`는 위젯의 현재 상태를 읽어오는 함수입니다.
>
> Preferences 방식을 쓰면 `Preferences` 타입을 받고, `intPreferencesKey`나 `stringPreferencesKey`로 값을 꺼냅니다. Proto 방식은 직접 정의한 데이터 클래스를 받아서 프로퍼티로 접근합니다.
>
> 중요한 건, 이 상태는 **위젯 인스턴스별로 독립적**이라는 점입니다. 같은 위젯을 3개 추가하면 각각 다른 `GlanceId`를 갖고, 각자의 상태를 따로 관리합니다.
>
> Compose의 `remember`와 비슷하지만, DataStore 기반이라 **프로세스 재시작 후에도 유지**됩니다."

---

### 3.2 인스턴스별 상태 자동 관리 원리

> [!QUESTION] 🤔 자주 하는 질문
> **Q**: 상태를 **쓸 때**는 `updateAppWidgetState(context, glanceId)`처럼 `glanceId`를 명시적으로 전달하는데, **읽을 때**는 `currentState()`에 `glanceId`를 전달하지 않는데 어떻게 자동으로 인스턴스별 상태를 가져오나요?

**A**: Glance 프레임워크가 **Composition Context에 GlanceId를 자동 주입**하기 때문입니다.

#### 3.2.1 내부 동작 원리

**Step 1: provideGlance의 id 파라미터**

```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    //                                              ↑ 이미 GlanceId를 받고 있음!
    provideContent {
        // 이 블록 내부는 특정 GlanceId의 "Composition Context"에서 실행됨
        val prefs = currentState<Preferences>()
    }
}
```

- `provideGlance`는 **시스템이 호출**하는 함수로, 이미 `id: GlanceId` 파라미터로 **어떤 위젯 인스턴스를 그려야 하는지** 알려줍니다.
- `provideContent { }` 블록은 이 `id`를 **내부적으로 Composition Context에 저장**합니다.

**Step 2: currentState()의 자동 추론**

```kotlin
// currentState() 개념적 동작 (의사코드)
@Composable
fun <T> currentState(): T {
    // 1. 컴포지션 컨텍스트에 바인딩된 현재 GlanceId 식별
    //    (Glance는 LocalGlanceId 같은 CompositionLocal을 통해 제공)
    val glanceId = /* 현재 컴포지션의 GlanceId */

    // 2. 해당 GlanceId에 매핑된 DataStore에서 상태 읽기
    val dataStore = stateDefinition.getDataStore(context, glanceId)

    // 3. 상태 반환
    return dataStore.data.first()
}
```

- `currentState()`는 `@Composable` 함수로, **컴포지션 컨텍스트에 바인딩된 현재 GlanceId**를 바탕으로 상태 저장소를 조회합니다.
- Glance는 `LocalGlanceId` 같은 CompositionLocal을 통해 현재 렌더링 중인 위젯 인스턴스를 식별합니다.
- 따라서 **명시적으로 전달하지 않아도** 자동으로 올바른 위젯 인스턴스의 상태를 읽습니다.

**Step 3: 각 위젯 인스턴스는 별도 DataStore 파일 사용**

```kotlin
// 개념적 파일 시스템 구조 (실제 파일명은 구현에 따라 다를 수 있음)
/data/data/com.example.app/files/datastore/
├── [인스턴스 A의 고유 파일]  // GlanceId A → fileKey A
├── [인스턴스 B의 고유 파일]  // GlanceId B → fileKey B
└── [인스턴스 C의 고유 파일]  // GlanceId C → fileKey C
```

- `GlanceStateDefinition`은 각 `GlanceId`를 인스턴스 고유의 `fileKey`로 매핑합니다.
- `getDataStore(context, fileKey)`와 `getLocation(context, fileKey)`를 통해 인스턴스별 별도 DataStore 파일을 생성/조회합니다.
- 따라서 위젯 인스턴스별로 **완전히 독립적인 상태 저장소**를 갖습니다.

> [!NOTE] 📝 구현 세부사항
> 실제 파일명이나 경로 형식은 Glance 라이브러리 버전에 따라 달라질 수 있습니다.
> 중요한 것은 **각 인스턴스가 고유한 저장소를 갖는다**는 API 수준의 보장입니다.

#### 3.2.2 왜 쓸 때는 glanceId를 명시적으로 전달해야 하나?

> [!NOTE] 💡 예제 2의 초점
> 이 예제는 **Composable 블록 외부에서의 동작 원리**를 설명합니다:
> - ActionCallback/Worker는 Composition Context가 없음
> - 따라서 GlanceId를 명시적으로 전달해야 함
> - 시스템이 어떤 위젯 인스턴스를 업데이트할지 명확히 지정

```kotlin
// ❌ provideContent 외부에서는 Composition Context가 없음
class IncrementAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,  // ActionCallback이 제공
        parameters: ActionParameters
    ) {
        // 여기는 Composable 블록이 아니므로 LocalGlanceId.current를 쓸 수 없음!
        // 따라서 명시적으로 glanceId를 전달해야 함
        updateAppWidgetState(context, glanceId) { prefs ->
            //                           ↑ 필수!
            prefs[intPreferencesKey("count")] = 42
        }
    }
}

// ❌ Worker에서도 마찬가지
class DataSyncWorker : CoroutineWorker(...) {
    override suspend fun doWork(): Result {
        // Worker는 위젯 외부에서 실행되므로 Composition Context가 없음
        val manager = GlanceAppWidgetManager(applicationContext)
        val glanceIds = manager.getGlanceIds(MyWidget::class.java)

        glanceIds.forEach { glanceId ->
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                //                                     ↑ 명시적 전달 필수
                prefs[stringPreferencesKey("data")] = "updated"
            }
        }
        return Result.success()
    }
}
```

**이유**:
- `ActionCallback`이나 `Worker`는 **위젯 외부**에서 실행되는 코드입니다.
- **Composable Context가 없으므로** `LocalGlanceId.current`를 사용할 수 없습니다.
- 따라서 `updateAppWidgetState(context, glanceId)`처럼 **명시적으로 어떤 위젯의 상태를 변경할지** 전달해야 합니다.

#### 3.2.3 비교: 읽기 vs 쓰기

| 상황 | 위치 | GlanceId 전달 | 이유 |
|------|------|--------------|------|
| **상태 읽기** | `provideContent { }` 내부 | ❌ 불필요 | Composition Context에서 자동 추론 |
| **상태 쓰기** | `ActionCallback`, `Worker` | ✅ 필수 | Composable 블록 외부라서 명시 필요 |

#### 3.2.4 실전 예제: 전체 흐름

> [!NOTE] 💡 예제 3의 초점
> 이 예제는 **시스템 전체 흐름의 이해**를 돕습니다:
> - 시스템이 GlanceId를 어떻게 전달하는지
> - provideContent 내부(읽기)와 ActionCallback(쓰기)의 차이
> - 상태 변경 → UI 업데이트의 완전한 사이클

```kotlin
// 1. 시스템이 위젯을 렌더링할 때
class MyWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        //                                              ↑ 시스템이 제공 (예: id=123)

        // 2. provideContent 블록은 id=123의 Context에서 실행
        provideContent {
            // 3. currentState()는 자동으로 id=123의 상태를 읽음
            val prefs = currentState<Preferences>()
            //          ↑ 컴포지션 컨텍스트에서 GlanceId=123 자동 식별
            //          ↑ 해당 인스턴스의 DataStore 파일 읽기

            val count = prefs[intPreferencesKey("count")] ?: 0

            Text("Count: $count")
            Button("증가", onClick = actionRunCallback<IncrementAction>())
        }
    }
}

// 4. 사용자가 버튼을 클릭하면
class IncrementAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,  // 시스템이 제공 (예: glanceId=123)
        parameters: ActionParameters
    ) {
        // 5. 여기는 Composable 블록이 아니므로 glanceId를 명시적으로 전달
        updateAppWidgetState(context, glanceId) { prefs ->
            //                           ↑ 필수! (glanceId=123)
            //                           ↑ 해당 인스턴스의 DataStore 파일에 쓰기
            val current = prefs[intPreferencesKey("count")] ?: 0
            prefs[intPreferencesKey("count")] = current + 1
        }

        // 6. UI 업데이트 → 다시 provideGlance(id=123) 호출
        MyWidget().update(context, glanceId)
    }
}
```

> [!TIP] 💡 핵심 정리
> **읽기 (provideContent 내부)**:
> - ✅ `currentState()`로 자동 추론
> - ✅ 컴포지션 컨텍스트에 바인딩된 GlanceId를 바탕으로 상태 조회
> - ✅ 개발자가 GlanceId를 명시적으로 전달할 필요 없음
>
> **쓰기 (ActionCallback, Worker 등 외부)**:
> - ✅ `updateAppWidgetState(context, glanceId)`로 명시적 전달 필수
> - ✅ Composable 블록 외부에서는 컨텍스트 기반 자동 추론 불가
> - ✅ 어떤 위젯 인스턴스를 업데이트할지 명확하게 지정
>
> **결론**: Glance는 **CompositionLocal(예: LocalGlanceId)** 같은 메커니즘을 활용해 `provideContent` 내부에서는 GlanceId를 자동 관리하고, 외부에서는 명시적 전달을 요구하여 **타입 안정성과 편의성을 동시에** 제공합니다.

---

## 4. 상태 쓰기

### 4.1 updateAppWidgetState (단일 위젯)

> [!NOTE] 💡 예제 4의 초점
> 이 예제는 **updateAppWidgetState API의 상세 사용법**을 설명합니다:
> - Preferences 방식과 Proto 방식의 차이
> - 상태 변경 후 반드시 update() 호출 필요
> - Preferences는 mutable, Proto는 불변 객체 (빌더 패턴)

```kotlin
class IncrementAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // Preferences 방식
        updateAppWidgetState(context, glanceId) { prefs ->
            val current = prefs[intPreferencesKey("count")] ?: 0
            prefs[intPreferencesKey("count")] = current + 1
        }

        // Proto 방식 (복사 후 수정)
        updateAppWidgetState(context, glanceId) { state: WidgetState ->
            state.toBuilder()
                .setCounter(state.counter + 1)
                .build()
        }

        // 반드시 update() 호출!
        MyWidget().update(context, glanceId)
    }
}
```

> [!NOTE] 
> "상태를 변경하는 흐름은 **2단계**입니다.
>
> 1. **`updateAppWidgetState`로 상태 변경**: 람다 안에서 기존 값을 읽고, 새 값을 설정합니다. Preferences 방식은 mutable하게 직접 수정하고, Proto 방식은 불변 객체라서 빌더로 복사 후 수정합니다.
>
> 2. **`update()` 호출로 UI 갱신**: 상태만 바꿔서는 화면이 안 바뀝니다. 반드시 `MyWidget().update(context, glanceId)`를 호출해야 `provideContent`가 다시 실행되고 UI가 새로 그려집니다.
>
> 이 두 단계를 빼먹으면 안 됩니다. 상태는 바뀌었는데 화면은 그대로거나, 상태는 그대로인데 UI만 다시 그려지는 상황이 생길 수 있어요."

**[스크린샷 추천]** 상태 변경 전후 비교 (카운터 0 → 1)

---

### 4.2 updateAll (모든 위젯 인스턴스)
```kotlin
class RefreshAllAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 모든 위젯 인스턴스의 상태를 동일하게 변경
        val manager = GlanceAppWidgetManager(context)
        val glanceIds = manager.getGlanceIds(MyWidget::class.java)

        glanceIds.forEach { id ->
            updateAppWidgetState(context, id) { prefs ->
                prefs[longPreferencesKey("last_sync")] = System.currentTimeMillis()
            }
        }

        // 모든 위젯 UI 갱신
        MyWidget().updateAll(context)
    }
}
```

---

## 5. 실전 패턴(생략)

### 5.1 초기 상태 설정
```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    override val glanceAppWidget = MyWidget()

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        super.onUpdate(context, appWidgetManager, appWidgetIds)

        // 각 위젯 인스턴스에 초기 상태 설정
        appWidgetIds.forEach { appWidgetId ->
            val glanceId = GlanceAppWidgetManager(context)
                .getGlanceIdBy(appWidgetId)

            lifecycleScope.launch {
                updateAppWidgetState(context, glanceId) { prefs ->
                    if (!prefs.contains(intPreferencesKey("count"))) {
                        prefs[intPreferencesKey("count")] = 0
                    }
                    prefs[longPreferencesKey("created_at")] = System.currentTimeMillis()
                }
                MyWidget().update(context, glanceId)
            }
        }
    }
}
```

---

### 5.2 외부 데이터와 동기화 (Repository 패턴)
```kotlin
class DataSyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        // 1. API 호출
        val data = apiService.fetchData()

        // 2. 모든 위젯 상태 업데이트
        val manager = GlanceAppWidgetManager(applicationContext)
        val glanceIds = manager.getGlanceIds(MyWidget::class.java)

        glanceIds.forEach { glanceId ->
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                prefs[stringPreferencesKey("data")] = data.toString()
                prefs[longPreferencesKey("last_update")] = System.currentTimeMillis()
            }
        }

        // 3. UI 갱신
        MyWidget().updateAll(applicationContext)

        return Result.success()
    }
}
```

**[비디오 추천]** Worker 실행 → API 호출 → 위젯 상태 변경 → UI 자동 갱신 흐름

---

### 5.3 조건부 상태 변경
```kotlin
class ToggleAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        updateAppWidgetState(context, glanceId) { prefs ->
            val isEnabled = prefs[booleanPreferencesKey("is_enabled")] ?: false

            if (isEnabled) {
                // 비활성화
                prefs[booleanPreferencesKey("is_enabled")] = false
                prefs[stringPreferencesKey("status")] = "OFF"
            } else {
                // 활성화
                prefs[booleanPreferencesKey("is_enabled")] = true
                prefs[stringPreferencesKey("status")] = "ON"
                prefs[longPreferencesKey("enabled_at")] = System.currentTimeMillis()
            }
        }

        MyWidget().update(context, glanceId)
    }
}
```

---

### 5.4 상태 기반 UI 분기
```kotlin
override suspend fun provideGlance(context: Context, id: GlanceId) {
    provideContent {
        val prefs = currentState<Preferences>()
        val status = prefs[stringPreferencesKey("status")] ?: "idle"

        when (status) {
            "loading" -> LoadingUI()
            "success" -> SuccessUI(prefs)
            "error" -> ErrorUI(prefs[stringPreferencesKey("error_msg")])
            else -> IdleUI()
        }
    }
}

@Composable
fun LoadingUI() {
    Box(
        modifier = GlanceModifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator()
        Text("로딩 중...")
    }
}

@Composable
fun SuccessUI(prefs: Preferences) {
    val data = prefs[stringPreferencesKey("data")] ?: ""
    Column {
        Text("성공!", style = TextStyle(fontWeight = FontWeight.Bold))
        Text(data)
    }
}

@Composable
fun ErrorUI(message: String?) {
    Column {
        Text("오류 발생", style = TextStyle(color = ColorProvider(Color.Red)))
        Text(message ?: "알 수 없는 오류")
        Button("재시도", onClick = actionRunCallback<RetryAction>())
    }
}
```

**[스크린샷 추천]** 상태별 UI 변화 (idle, loading, success, error)

---

## 6. 상태 관리 베스트 프랙티스

### ✅ DO
- **작은 데이터만 저장** (수십 KB 이내)
- **상태 변경 후 즉시 update() 호출**
- **기본값 제공** (?: 0, ?: "default")
- **인스턴스별 독립성 유지** (GlanceId 활용)
- **무거운 데이터는 외부 저장소**(Room, File) + Glance에는 ID만 저장

### ❌ DON'T
- **대용량 데이터 저장 금지** (이미지, 긴 텍스트)
- **상태 변경만 하고 update() 생략**
- **동기화 블로킹 작업** (네트워크, DB)
- **상태에 민감 정보 저장** (토큰, 비밀번호)

---

## 7. 실전 예제: 날씨 위젯

```kotlin
data class WeatherData(
    val temperature: Int,
    val condition: String,
    val lastUpdate: Long
)

class WeatherWidget : GlanceAppWidget() {
    override val stateDefinition = PreferencesGlanceStateDefinition

    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            val prefs = currentState<Preferences>()
            val temp = prefs[intPreferencesKey("temperature")] ?: 0
            val condition = prefs[stringPreferencesKey("condition")] ?: "알 수 없음"
            val isLoading = prefs[booleanPreferencesKey("is_loading")] ?: false
            val lastUpdate = prefs[longPreferencesKey("last_update")] ?: 0L

            Column(
                modifier = GlanceModifier
                    .fillMaxSize()
                    .padding(16.dp)
                    .background(Color.LightGray)
            ) {
                if (isLoading) {
                    Text("날씨 정보 가져오는 중...")
                    CircularProgressIndicator()
                } else {
                    Text("🌤️ $condition", style = TextStyle(fontSize = 24.sp))
                    Text("$temp°C", style = TextStyle(fontSize = 48.sp, fontWeight = FontWeight.Bold))

                    Spacer(GlanceModifier.height(8.dp))

                    Text(
                        "최근 업데이트: ${formatTime(lastUpdate)}",
                        style = TextStyle(fontSize = 12.sp, color = ColorProvider(Color.Gray))
                    )
                }

                Spacer(GlanceModifier.defaultWeight())

                Button(
                    text = "새로고침",
                    onClick = actionRunCallback<RefreshWeatherAction>(),
                    modifier = GlanceModifier.fillMaxWidth()
                )
            }
        }
    }
}

class RefreshWeatherAction : ActionCallback {
    override suspend fun onAction(
        context: Context,
        glanceId: GlanceId,
        parameters: ActionParameters
    ) {
        // 1. 로딩 상태로 변경
        updateAppWidgetState(context, glanceId) { prefs ->
            prefs[booleanPreferencesKey("is_loading")] = true
        }
        WeatherWidget().update(context, glanceId)

        // 2. Worker로 날씨 데이터 가져오기 (비동기)
        val workRequest = OneTimeWorkRequestBuilder<WeatherWorker>()
            .setInputData(workDataOf("glance_id" to glanceId.toString()))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)
    }
}

class WeatherWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        val glanceIdString = inputData.getString("glance_id") ?: return Result.failure()
        val glanceId = GlanceAppWidgetManager(applicationContext)
            .getGlanceIds(WeatherWidget::class.java)
            .find { it.toString() == glanceIdString }
            ?: return Result.failure()

        try {
            // API 호출
            val weather = weatherApi.getCurrentWeather()

            // 상태 업데이트
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                prefs[intPreferencesKey("temperature")] = weather.temp
                prefs[stringPreferencesKey("condition")] = weather.condition
                prefs[longPreferencesKey("last_update")] = System.currentTimeMillis()
                prefs[booleanPreferencesKey("is_loading")] = false
            }

            // UI 갱신
            WeatherWidget().update(applicationContext, glanceId)

            return Result.success()
        } catch (e: Exception) {
            // 에러 상태 저장
            updateAppWidgetState(applicationContext, glanceId) { prefs ->
                prefs[booleanPreferencesKey("is_loading")] = false
                prefs[stringPreferencesKey("condition")] = "오류"
            }
            WeatherWidget().update(applicationContext, glanceId)

            return Result.failure()
        }
    }
}
```

**[스크린샷 추천]** 날씨 위젯 전체 UI (온도, 날씨 상태, 마지막 업데이트 시간, 새로고침 버튼)

---