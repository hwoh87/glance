> [!TIP] 🗣️ 핵심내용
Glance Composable이 어떻게 `RemoteViews`로 변환되어 실제 위젯으로 표시되는지 내부 동작 원리를 이해합니다.
>

## 1. 렌더링 파이프라인 개요

```
📱 런처
   │ (위젯 추가, ProviderInfo 읽기)
   ▼
📑 initialLayout (플레이스홀더)
   │
   ▼
📡 GlanceAppWidgetReceiver
   │ (provideGlance 호출)
   ▼
🧩 Glance DSL → RemoteViews 변환
   │
   ▼
🎨 AppWidgetManager 적용 → 실제 UI 표시
```

### 1.1 전통 위젯과의 렌더링 파이프라인 비교

**전통 위젯 렌더링 과정**
```
📱 런처
   │ (위젯 추가)
   ▼
📡 AppWidgetProvider.onUpdate()
   │
   ▼
📑 XML 레이아웃 inflate
   │
   ▼
🔧 RemoteViews 객체 생성
   │
   ▼
⚙️ setTextViewText(), setOnClickPendingIntent() 등으로 수동 조작
   │
   ▼
🎨 AppWidgetManager.updateAppWidget() 호출
   │
   ▼
✅ 위젯 UI 표시
```

```kotlin
// 전통 위젯: 모든 단계를 개발자가 직접 관리
class TraditionalWidget : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        appWidgetIds.forEach { appWidgetId ->
            // 1. XML 기반 RemoteViews 생성
            val views = RemoteViews(context.packageName, R.layout.widget_layout)

            // 2. 수동으로 각 뷰 조작
            views.setTextViewText(R.id.title, "Hello")
            views.setTextViewText(R.id.subtitle, "World")

            // 3. 클릭 이벤트 수동 설정
            val intent = Intent(context, MainActivity::class.java)
            val pendingIntent = PendingIntent.getActivity(context, 0, intent, 0)
            views.setOnClickPendingIntent(R.id.button, pendingIntent)

            // 4. 수동으로 업데이트 적용
            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}
```

**Glance 위젯 렌더링 과정**
```
📱 런처
   │ (위젯 추가)
   ▼
📡 GlanceAppWidgetReceiver → provideGlance()
   │
   ▼
🎨 provideContent { } (선언형 DSL)
   │
   ▼
🔄 Glance 내부 엔진이 자동으로 RemoteViews 변환
   │
   ▼
✅ 위젯 UI 표시 (개발자는 DSL만 작성)
```

```kotlin
// Glance 위젯: 선언형 DSL만 작성, 나머지는 자동
class ModernWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // Compose 스타일 선언만으로 끝
            Column {
                Text("Hello")
                Text("World")
                Button("Click", onClick = actionStartActivity<MainActivity>())
            }
            // RemoteViews 변환, 이벤트 연결, 업데이트 모두 자동 처리
        }
    }
}
```

**핵심 차이점**:
- **전통 방식**: XML → RemoteViews 생성 → 수동 조작 → 업데이트 (4단계)
- **Glance 방식**: DSL 선언 → 자동 처리 (1단계)
- **개발자 부담**: RemoteViews API 직접 다루기 vs 익숙한 Compose 스타일 작성

---

## 2. 렌더링 단계별 설명

### 2.1 초기 표시 (플레이스홀더)

사용자가 홈 화면에 위젯을 추가하면, 시스템은 먼저 `AppWidgetProviderInfo`를 읽고 **`initialLayout`**을 즉시 표시합니다.

```xml
<!-- res/xml/widget_info.xml -->
<appwidget-provider
    android:initialLayout="@layout/placeholder"  <!-- 필수! -->
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:previewImage="@drawable/widget_preview"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen" />
```

```xml
<!-- res/layout/placeholder.xml -->
<TextView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:text="Loading..."
    android:gravity="center"
    android:background="#FFFFFF" />
```

> [!NOTE] 💬 발표 설명
> "`initialLayout`은 **플레이스홀더**입니다. 위젯이 추가되는 순간 시스템이 즉시 보여주는 임시 레이아웃이죠.
>
> Glance가 실제 UI를 렌더링하기 전까지 잠깐 보이는 화면입니다. 'Loading...' 같은 단순한 텍스트나 로고 정도면 충분합니다.
>
> **중요한 점**: 이 리소스 파일이 실제로 존재해야 합니다. 없으면 위젯 선택 화면에 아예 안 뜰 수 있어요. XML 파일 하나 만들고, 간단한 TextView 하나 넣으면 됩니다."

**중요**: `initialLayout` 리소스가 없으면 위젯이 **위젯 목록에 미노출**될 수 있습니다.

---

### 2.2 진입 (Receiver 호출)

시스템은 `GlanceAppWidgetReceiver`를 통해 위젯 클래스의 `provideGlance()`를 호출합니다.

**호출 시점**:
- 위젯 추가 시
- 위젯 업데이트 시
- 위젯 리사이즈 시
- 옵션(Bundle) 변경 시

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    override val glanceAppWidget: GlanceAppWidget = MyWidget()
}
```

---

### 2.3 DSL → RemoteViews 변환

`provideContent {}` 안에서 Glance DSL로 UI를 선언하면, Glance가 **`RemoteViews`**로 변환합니다.

```kotlin
class MyWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // Glance DSL
            Column {
                Text("Hello")
                Button("Click", onClick = { /* ... */ })
            }
            // ↓ 내부적으로 RemoteViews로 변환
        }
    }
}
```

> [!NOTE] 💬 발표 설명
> "여기가 Glance의 핵심입니다. `provideContent` 블록 안에서 선언한 DSL 코드가 자동으로 RemoteViews로 변환됩니다.
>
> 우리는 Column, Text, Button 같은 익숙한 컴포넌트로 UI를 작성하기만 하면 되고, Glance가 알아서 RemoteViews API 호출로 바꿔줍니다.
>
> 변환 방식은 `SizeMode`에 따라 달라집니다:
> - **Single**: 크기 상관없이 한 번만 렌더링
> - **Exact**: 정확한 픽셀 크기마다 새로 렌더링 (리소스 소모 큼)
> - **Responsive**: 대표 크기들을 미리 렌더링해서 맵으로 저장 (Android 12+, 추천)"

---

### 2.4 화면 적용

생성된 `RemoteViews`는 `AppWidgetManager`를 통해 런처에 적용되고, 플레이스홀더가 실제 UI로 교체됩니다.
```
Glance DSL → RemoteViews → AppWidgetManager → 런처 → 사용자 화면
```

---

## 3. 업데이트 트리거

위젯 UI를 갱신하는 방법은 다음과 같습니다:

- **수동 업데이트**: `update()`, `updateAll()` 호출
- **상태 변경 후**: `updateAppWidgetState()` + `update()` 호출
- **시스템 트리거**: 리사이즈, 옵션 변경, 재부팅
- **백그라운드 트리거**: `WorkManager`에서 `updateAll()` 호출

**업데이트 트리거에 대한 자세한 내용은 → [5. Glance 생명주기 & 업데이트 트리거⭐](5.%20Glance%20생명주기%20&%20업데이트%20트리거⭐.md)** 참고

---

## 4. 프로세스 및 수명주기 특성

### 4.1 프로세스 분리

위젯은 **별도 프로세스**에서 실행됩니다. 이 프로세스는 자주 종료될 수 있습니다.

**권장 사항**:
- 무거운 I/O/네트워크 작업은 `Worker`나 `Repository`로 분리
- `provideContent`는 빠르게 `RemoteViews`를 생성해야 함 (블로킹 금지)

### 4.2 여러 인스턴스 관리

홈 화면에 같은 위젯을 여러 개 추가하면 각각 다른 `GlanceId`를 가집니다.

```kotlin
// 인스턴스별로 독립적인 상태
updateAppWidgetState(context, glanceId1) { /* ... */ }
updateAppWidgetState(context, glanceId2) { /* ... */ }
```

---