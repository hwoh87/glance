> [!TIP] 🗣️ 핵심내용
Android의 `AppWidgetProvider`를 확장한 클래스로, 위젯의 진입점 역할을 합니다.
>

## 1. GlanceAppWidgetReceiver 개요

```
📱 시스템 (런처/OS 이벤트)
       │
       ▼
📡 GlanceAppWidgetReceiver
       │  (GlanceAppWidget 연결)
       ▼
🧩 MyGlanceWidget (GlanceAppWidget)
```

> [!NOTE] 💬 NOTE
> "`GlanceAppWidgetReceiver`는 위젯의 **진입점으로 시스템과 우리가 작성한 위젯 코드를 연결하는 중간 다리 역할
>
> 런처에서 위젯을 추가하거나, 크기를 변경하거나, 업데이트 시간이 되면 시스템이 브로드캐스트를 보내는데 이 Receiver가 그걸 받아서 우리가 작성한 `GlanceAppWidget`으로 전달
>
> 전통 위젯의 `AppWidgetProvider`의 역할을 GlanceAppWidgetReceiver가 수행
### 1.1 핵심 역할
- `AppWidgetProvider`를 대체하는 **Glance 전용 리시버**
- 시스템 브로드캐스트(`APPWIDGET_UPDATE` 등) 수신
- 반드시 매니페스트에 receiver 등록 필요
- `glanceAppWidget` 프로퍼티로 **연결 대상 위젯 지정
- 내부적으로 `GlanceAppWidget.provideGlance()` 실행

---

## 2. 기본 구현

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    // 필수: 연결할 GlanceAppWidget 지정
    override val glanceAppWidget: GlanceAppWidget = MyWidget()
}
```

```xml
<!-- AndroidManifest.xml -->
<receiver
    android:name=".MyWidgetReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/my_widget_info" />
</receiver>
```

### 2.1  생명주기 콜백 (선택적 오버라이드)

`GlanceAppWidgetReceiver`는 다음과 같은 생명주기 콜백을 제공합니다:
- **`onEnabled()`**: 첫 번째 위젯 추가 시
- **`onUpdate()`**: 위젯 업데이트 필요 시
- **`onDeleted()`**: 위젯 삭제 시
- **`onDisabled()`**: 마지막 위젯 제거 시

**자세한 생명주기 설명과 예제는 → [3. Glance 생명주기 & 업데이트 트리거⭐⭐](3.%20Glance%20생명주기%20&%20업데이트%20트리거⭐⭐.md)** 참고

## 2.2 AppWidgetProviderInfo 설정

Manifest의 `meta-data`에서 참조하는 위젯 설정 XML 파일입니다. 시스템이 이 파일을 읽어 위젯의 크기, 업데이트 주기, 미리보기 이미지 등을 파악합니다.

### 2.1.1 필수 속성

```xml
<!-- res/xml/my_widget_info.xml -->
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_placeholder"
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen" />
```

| 속성               | 설명                                                                 | 필수 여부 |
| ---------------- | ------------------------------------------------------------------ | ----- |
| `initialLayout`  | 위젯 로딩 중 임시로 표시될 플레이스홀더 레이아웃                                        | ✅ 필수  |
| `minWidth`       | 위젯 최소 가로 크기 (dp)                                                   | ✅ 필수  |
| `minHeight`      | 위젯 최소 세로 크기 (dp)                                                   | ✅ 필수  |
| `resizeMode`     | 리사이즈 방향 (`horizontal`, `vertical`, `horizontal\|vertical`, `none`) | 권장    |
| `widgetCategory` | 위젯 표시 위치 (`home_screen`, `keyguard`, `searchbox`)                  | 권장    |

> [!IMPORTANT]
> **`initialLayout`은 절대 필수**입니다. 이 리소스가 없으면 위젯이 위젯 선택 화면에 아예 나타나지 않을 수 있습니다.

---

### 2.1.2 initialLayout 플레이스홀더

위젯 추가 시 Glance가 실제 UI를 렌더링하기 전까지 **몇 밀리초~1초 정도** 임시로 보여줄 레이아웃입니다.

```xml
<!-- res/layout/widget_placeholder.xml -->
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:text="Loading..."
    android:gravity="center"
    android:textColor="#666666"
    android:background="#FFFFFF" />
```

> [!NOTE] 💬 NOTE
> "`initialLayout`은 **플레이스홀더**입니다. 위젯이 추가되는 순간 시스템이 즉시 보여주는 임시 레이아웃이죠.
>
> Glance가 `provideGlance()`를 실행해서 실제 UI를 만들기 전까지 잠깐 보이는 화면입니다. 'Loading...' 같은 단순한 텍스트나 로고 정도면 충분합니다.
>
> **중요한 점**: 이 리소스 파일이 실제로 존재해야 합니다. 없으면 위젯 선택 화면에 아예 안 뜰 수 있어요. XML 파일 하나 만들고, 간단한 TextView 하나 넣으면 됩니다."

**플레이스홀더 작성 팁**:
- ✅ **반드시 생성**: XML 레이아웃 파일이 실제로 존재해야 함
- ✅ **단순하게**: TextView 하나 정도로 충분
- ✅ **빠른 로딩**: 무거운 레이아웃 피하기
- ⚠️ **미노출 위험**: 없으면 위젯 목록에 안 뜰 수 있음

---

### 2.1.3 크기 관련 속성

```xml
<appwidget-provider
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:minResizeWidth="110dp"
    android:minResizeHeight="40dp"
    android:maxResizeWidth="320dp"
    android:maxResizeHeight="400dp"
    android:targetCellWidth="3"
    android:targetCellHeight="2" />
```

| 속성 | 설명 | 사용 시점 |
|------|------|----------|
| `minResizeWidth` | 사용자가 리사이즈 가능한 최소 가로 크기 | `resizeMode` 포함 시 |
| `minResizeHeight` | 사용자가 리사이즈 가능한 최소 세로 크기 | `resizeMode` 포함 시 |
| `maxResizeWidth` | 리사이즈 가능한 최대 가로 크기 (API 31+) | 최대 크기 제한 필요 시 |
| `maxResizeHeight` | 리사이즈 가능한 최대 세로 크기 (API 31+) | 최대 크기 제한 필요 시 |
| `targetCellWidth` | 권장 가로 셀 수 (API 31+) | 그리드 기반 레이아웃 |
| `targetCellHeight` | 권장 세로 셀 수 (API 31+) | 그리드 기반 레이아웃 |

> [!TIP]
> **SizeMode와의 관계**: XML에서 정의한 크기는 **시스템이 위젯을 배치할 때** 사용하는 힌트입니다. 실제 UI는 `GlanceAppWidget`의 `sizeMode`로 대응합니다.
>
> 자세한 내용: **[8. SizeMode⭐](8.%20SizeMode⭐.md)**

---

### 2.1.4 업데이트 주기

```xml
<appwidget-provider
    android:updatePeriodMillis="1800000" />
```

| 속성                   | 설명                   | 기본값         |
| -------------------- | -------------------- | ----------- |
| `updatePeriodMillis` | 시스템 자동 업데이트 주기 (밀리초) | 0 (업데이트 없음) |

> [!WARNING]
> **제약사항**:
> - 최소값: `1800000` (30분) - 더 짧게 설정해도 시스템이 30분으로 조정
> - 배터리 절약 모드에서는 무시될 수 있음
> - **권장**: WorkManager로 주기적 업데이트 구현 (더 유연함)

---

### 2.1.5 UI 미리보기

```xml
<appwidget-provider
    android:previewImage="@drawable/widget_preview"
    android:previewLayout="@layout/widget_preview_layout"
    android:description="@string/widget_description" />
```

| 속성              | 설명                        | API 레벨  |
| --------------- | ------------------------- | ------- |
| `previewImage`  | 위젯 선택 화면에 표시될 미리보기 이미지    | API 11+ |
| `previewLayout` | 동적 미리보기 레이아웃 (실제 위젯처럼 표시) | API 31+ |
| `description`   | 위젯 설명 (접근성)               | API 12+ |

> [!NOTE]
> **description은 반드시 string 리소스**로 정의해야 합니다. 직접 텍스트를 입력하면 빌드 에러가 발생합니다.
> ```xml
> <!-- ❌ 잘못된 예 -->
> android:description="날씨 위젯"
>
> <!-- ✅ 올바른 예 -->
> android:description="@string/weather_widget_description"
> ```

**[스크린샷]** 위젯 선택 화면에서 previewImage가 표시되는 모습
![[스크린샷 2025-10-14 오후 11.48.19.png|300]]
---

### 2.1.6 위젯 카테고리 & 기능

```xml
<appwidget-provider
    android:widgetCategory="home_screen|keyguard"
    android:widgetFeatures="reconfigurable|configuration_optional" />
```

**widgetCategory**:
- `home_screen`: 홈 화면 (기본값)
- `keyguard`: 잠금 화면 (API 17+, Android 5.0부터 deprecated)
- `searchbox`: 검색 위젯 (특수 용도)

**widgetFeatures** (API 21+):
- `reconfigurable`: 홈 화면에 추가된 후에도 설정을 다시 열 수 있음을 런처에 알림
- `configuration_optional`: 위젯 추가 시, 설정 화면을 띄울지 말지 **“선택적”**임을 런처에 알림
- 기본값 :  **reconfigurable=false**, **configuration_optional=false** 로 동작

> [!NOTE]
>|**구분**|reconfigurable|configuration_optional|**둘 다 지정**|
|---|---|---|---|
|**추가 시**|항상 설정화면 실행|런처가 건너뛸 수도 있음|건너뛸 수도 있음|
|**기본값 배치**|불가능|가능|가능|
|**추가 후 재설정**|런처 지원 시 가능|불가능|가능|
|**대표 용도**|설정 필수형 위젯(예: 계좌, 지역 선택)|설정 거의 필요 없음(예: 시계, 날짜)|설정 선택+재설정 가능(예: 날씨, 뉴스)|

**[스크린샷]** reconfigurable으로 인해 기본값으로 바로 올리고 → 길게 눌러 **편집** 진입 가능.
![[스크린샷 2025-10-15 오전 12.03.01.png|300]]

---

### 2.1.7 설정 화면 (선택)

```xml
<appwidget-provider
    android:configure="com.example.MyWidgetConfigActivity" />
```

**[스크린샷]** 위젯 설정 화면
![[스크린샷 2025-10-15 오전 12.17.06 1.png|300]]
---

### 2.1.8 전체 예시

```xml
<!-- res/xml/weather_widget_info.xml -->
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_placeholder"
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:minResizeWidth="110dp"
    android:minResizeHeight="40dp"
    android:maxResizeWidth="320dp"
    android:maxResizeHeight="400dp"
    android:resizeMode="horizontal|vertical"
    android:updatePeriodMillis="1800000"
    android:previewImage="@drawable/weather_widget_preview"
    android:previewLayout="@layout/weather_widget_preview_layout"
    android:description="@string/weather_widget_description"
    android:widgetCategory="home_screen"
    android:widgetFeatures="reconfigurable|configuration_optional" />
```

---

## 3. 자동 vs 수동 업데이트

### 3.1 자동으로 처리되는 경우

`GlanceAppWidgetReceiver`는 시스템 이벤트를 받아 자동으로 `provideGlance()`를 호출합니다:

- ✅ 위젯 추가 (onEnabled)
- ✅ 시스템 업데이트 시간 도래 (onUpdate)
- ✅ 위젯 크기 변경
- ✅ 위젯 삭제 (onDeleted)

### 3.2 수동 업데이트가 필요한 경우

**앱 로직에 의한 데이터 변경**은 수동으로 업데이트를 호출해야 합니다:

- ✅ WorkManager 작업 완료 후 데이터 갱신
- ✅ 외부 브로드캐스트 수신 (알람, 배터리 상태 변경 등)
- ✅ 앱 내부 데이터베이스 변경
- ✅ 네트워크 API 응답 수신
- ✅ 사용자가 앱에서 설정 변경

```kotlin
// 예: WorkManager에서 데이터 로드 후
class DataSyncWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        // 1. 데이터 로드
        val newData = fetchDataFromServer()

        // 2. 상태 저장
        updateAppWidgetState(context, GlanceId(...)) { prefs ->
            prefs[dataKey] = newData
        }

        // 3. 수동으로 UI 갱신 요청 (필수!)
        MyWidget().updateAll(context)

        return Result.success()
    }
}
```

> [!NOTE] 💬 업데이트 방식의 차이
> - 자동 또는 수동 브로드캐스트 송신 : **onUpdate()가 호출**됨 → **super.onUpdate() 필수** → provideGlance()
> - 명시적 update()/updateAll() : **onUpdate() 없이** 곧바로 **provideGlance()**
> - onUpdate()에서는 **가벼운 일만** 하고 렌더는 **super**에 맡기기
> - RemoteViews 직접 주입은 **금지**(Glance 상태와 불일치)
>
> 자세한 내용: **[3. 생명주기 & 업데이트 트리거⭐⭐](3.%20Glance%20생명주기%20&%20업데이트%20트리거⭐⭐.md)**

---

## 4. 전통적인 방식과의 비교

### 4.1 렌더링 파이프라인 비교

**전통 위젯 렌더링 과정**
```
📱 런처
   │ (위젯 추가)
   ▼
📡 AppWidgetProvider.onUpdate()
   │
   ▼
📑 XML 레이아웃 inflate
   │
   ▼
🔧 RemoteViews 객체 생성
   │
   ▼
⚙️ setTextViewText(), setOnClickPendingIntent() 등으로 수동 조작
   │
   ▼
🎨 AppWidgetManager.updateAppWidget() 호출
   │
   ▼
✅ 위젯 UI 표시
```

```kotlin
// 전통 위젯: 모든 단계를 개발자가 직접 관리
class TraditionalWidget : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        appWidgetIds.forEach { appWidgetId ->
            // 1. XML 기반 RemoteViews 생성
            val views = RemoteViews(context.packageName, R.layout.widget_layout)

            // 2. 수동으로 각 뷰 조작
            views.setTextViewText(R.id.title, "Hello")
            views.setTextViewText(R.id.subtitle, "World")

            // 3. 클릭 이벤트 수동 설정
            val intent = Intent(context, MainActivity::class.java)
            val pendingIntent = PendingIntent.getActivity(context, 0, intent, 0)
            views.setOnClickPendingIntent(R.id.button, pendingIntent)

            // 4. 수동으로 업데이트 적용
            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}
```

**Glance 위젯 렌더링 과정**
```
📱 런처
   │ (위젯 추가)
   ▼
📡 GlanceAppWidgetReceiver → provideGlance()
   │
   ▼
🎨 provideContent { } (선언형 DSL)
   │
   ▼
🔄 Glance 내부 엔진이 자동으로 RemoteViews 변환
   │
   ▼
✅ 위젯 UI 표시 (개발자는 DSL만 작성)
```

```kotlin
// Glance 위젯: 선언형 DSL만 작성, 나머지는 자동
class ModernWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // Compose 스타일 선언만으로 끝
            Column {
                Text("Hello")
                Text("World")
                Button("Click", onClick = actionStartActivity<MainActivity>())
            }
            // RemoteViews 변환, 이벤트 연결, 업데이트 모두 자동 처리
        }
    }
}
```

**핵심 차이점**:
- **전통 방식**: XML → RemoteViews 생성 → 수동 조작 → 업데이트 (4단계)
- **Glance 방식**: DSL 선언 → 자동 처리 (1단계)
- **개발자 부담**: RemoteViews API 직접 다루기 vs 익숙한 Compose 스타일 작성

### 4.2 비교 표

| **구분**      | **전통 위젯**                    | **Glance 위젯**                        |
| ----------- | ---------------------------- | ------------------------------------ |
| **클래스**     | `AppWidgetProvider`          | `GlanceAppWidgetReceiver`            |
| **UI 작성**   | XML + `RemoteViews` 수동 조작    | Compose DSL (자동 `RemoteViews` 변환)    |
| **UI 업데이트** | `updateAppWidget()` 직접 호출    | `update()` / `updateAll()`           |
| **상태 관리**   | `SharedPreferences`/DB 직접 구현 | DataStore 기반 `StateDefinition` 기본 제공 |
| **개발 경험**   | 보일러플레이트 많음                   | 간결, Compose 친화적                      |
| **진입점**     | `onUpdate()` 메서드             | `glanceAppWidget` 프로퍼티               |
| **인스턴스 관리** | `appWidgetIds` 배열로 직접 반복     | `GlanceId` 자동 관리                     |

---

## 5. 주의사항

### 5.1 `super` 호출 필수
모든 생명주기 콜백에서 `super` 메서드를 호출해야 합니다. Glance의 내부 로직이 실행되어야 하기 때문입니다.

```kotlin
// ❌ 잘못된 예
override fun onUpdate(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetIds: IntArray
) {
    // super 호출 없음 → 위젯이 업데이트되지 않음!
}

// ✅ 올바른 예
override fun onUpdate(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetIds: IntArray
) {
     // 추가 로직...
    super.onUpdate(context, appWidgetManager, appWidgetIds)
}
```

### 5.2  super.onUpdate를 **중복 호출**
```kotlin
// ❌ 잘못된 예
appWidgetIds.forEach { appWidgetId ->
    val glanceId = GlanceAppWidgetManager(context).getGlanceIdBy(appWidgetId)
    CoroutineScope(Dispatchers.IO).launch {
        // 상태 초기화
        updateAppWidgetState(…, glanceId) { … }
        // UI 업데이트
        super.onUpdate(context, appWidgetManager, appWidgetIds)
    }
}
```
### 5.3 `onUpdate()` 직접 구현 지양
일반적으로 `onUpdate()`를 직접 오버라이드할 필요가 없습니다. `GlanceAppWidgetReceiver`가 자동으로 처리합니다.

---

## 6. 프로그래밍 방식 위젯 추가 (requestPinAppWidget)

### 6.1 개요
<video src="Screen_recording_20251016_015200.mp4" controls width="420"></video>
Android 8.0 (API 26)부터 앱 내에서 버튼을 눌러 위젯을 홈 화면에 추가할 수 있습니다.

```kotlin
// AppWidgetManager.requestPinAppWidget() 사용
사용자가 앱 버튼 클릭 → 시스템 승인 다이얼로그 → 홈 화면에 위젯 추가
```

> [!NOTE] 💬 NOTE
> "사용자가 **위젯 목록에서 꺼내는 방식**이 아니라, **앱 내에서 버튼으로 추가**하는 기능입니다.
>
> 온보딩이나 설정 완료 후 '위젯 추가하기' 버튼을 제공하면 사용자 경험이 훨씬 좋아집니다."

### 6.2 기본 구현

```kotlin
val requestPinWidget = {  
    // Android 8.0 (API 26) 미만에서는 지원하지 않음  
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {  
        Toast.makeText(  
            context,  
            "⚠️ Widget pinning requires Android 8.0 or higher",  
            Toast.LENGTH_LONG  
        ).show()  
    } else {  
        coroutineScope.launch {  
            // 1. 성공 콜백용 PendingIntent 생성 (선택사항)  
            val successCallback = PendingIntent.getBroadcast(  
                context,  
                0,  
                Intent(context, PinSuccessReceiver::class.java),  
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE  
            )  
  
            // 2. GlanceAppWidgetManager를 통해 위젯 고정 요청  
            // - receiver: 위젯을 수신할 Receiver 클래스  
            // - preview: 미리보기로 표시할 GlanceAppWidget 인스턴스  
            // - previewState: 위젯 미리보기 크기 (dp 단위)  
            // - successCallback: 성공 시 호출될 PendingIntent            val result = GlanceAppWidgetManager(context).requestPinGlanceAppWidget(  
                receiver = PinWidgetReceiver::class.java,  
                preview = PinWidget(),  
                previewState = DpSize(200.dp, 120.dp),  
                successCallback = successCallback  
            )  
  
            // 요청이 성공적으로 전송된 경우  
            if (result) {  
                Toast.makeText(  
                    context,  
                    "📌 Widget request sent!",  
                    Toast.LENGTH_SHORT  
                ).show()  
            } else {  
                Toast.makeText(  
                    context,  
                    "⚠️ Failed to send widget request",  
                    Toast.LENGTH_SHORT  
                ).show()  
            }  
        }  
    }  
}
```
### 6.3 요구사항 & 제약사항

**요구사항**:
- ✅ Android 8.0+ (API 26)
- ✅ 런처가 위젯 고정 지원 필요
- ✅ 사용자 명시적 승인 필요

**제약사항**:
- ⚠️ 런처마다 동작 다를 수 있음 (일부는 즉시 추가, 일부는 확인 다이얼로그)
- ⚠️ 너무 자주 요청하지 말 것 (사용자 경험 저하)
- ⚠️ 사용자가 거부한 경우 재요청 금지
---