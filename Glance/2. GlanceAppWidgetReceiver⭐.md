> [!TIP] 🗣️ 핵심내용
Android의 `AppWidgetProvider`를 확장한 클래스로, 위젯의 진입점 역할을 합니다.
>

## 1. GlanceAppWidgetReceiver 개요

```
📱 시스템 (런처/OS 이벤트)
       │
       ▼
📡 GlanceAppWidgetReceiver
       │  (GlanceAppWidget 연결)
       ▼
🧩 MyGlanceWidget (GlanceAppWidget)
```

> [!NOTE] 💬 발표 설명
> "`GlanceAppWidgetReceiver`는 위젯의 **진입점**입니다. 시스템과 우리가 작성한 위젯 코드를 연결하는 중간 다리 역할을 합니다.
>
> 런처에서 위젯을 추가하거나, 크기를 변경하거나, 업데이트 시간이 되면 시스템이 브로드캐스트를 보냅니다. 이 Receiver가 그걸 받아서 우리가 작성한 `GlanceAppWidget`으로 전달해주는 거죠.
>
> 전통 위젯의 `AppWidgetProvider`의 역할을 GlanceAppWidget이 하는 것 이라고 이해하시면 될 것 같습니다.
### 1.1 핵심 역할
- `AppWidgetProvider`를 대체하는 **Glance 전용 리시버**
- 시스템 브로드캐스트(`APPWIDGET_UPDATE` 등) 수신
- 내부적으로 `GlanceAppWidget.provideGlance()` 실행
- 반드시 매니페스트에 receiver 등록 필요
- `glanceAppWidget` 프로퍼티로 **연결 대상 위젯 지정**

---

## 2. 기본 구현

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    // 필수: 연결할 GlanceAppWidget 지정
    override val glanceAppWidget: GlanceAppWidget = MyWidget()
}
```

```xml
<!-- AndroidManifest.xml -->
<receiver
    android:name=".MyWidgetReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/my_widget_info" />
</receiver>
```

---

## 3. 생명주기 콜백 (선택적 오버라이드)

`GlanceAppWidgetReceiver`는 다음과 같은 생명주기 콜백을 제공합니다:

- **`onEnabled()`**: 첫 번째 위젯 추가 시
- **`onUpdate()`**: 위젯 업데이트 필요 시
- **`onDeleted()`**: 위젯 삭제 시
- **`onDisabled()`**: 마지막 위젯 제거 시

> [!NOTE] 💬 발표 설명
> "생명주기 콜백은 선택적으로 오버라이드할 수 있습니다.
>
> - **onEnabled**: 사용자가 **첫 번째 위젯**을 홈 화면에 추가할 때 딱 한 번 호출됩니다. WorkManager로 주기적 업데이트를 시작하는 용도로 많이 씁니다.
>
> - **onUpdate**: 위젯 업데이트가 필요할 때마다 호출됩니다. 하지만 Glance에서는 이걸 직접 오버라이드할 필요가 거의 없습니다. Glance가 자동으로 처리해주거든요.
>
> - **onDeleted**: 특정 위젯 인스턴스가 삭제될 때 호출됩니다. 해당 인스턴스의 상태 데이터를 정리하는 용도입니다.
>
> - **onDisabled**: **마지막 남은 위젯**이 제거될 때 호출됩니다. 여기서 WorkManager를 중지하거나 전역 리소스를 정리합니다."

**자세한 생명주기 설명과 예제는 → [5. Glance 생명주기 & 업데이트 트리거⭐](5.%20Glance%20생명주기%20&%20업데이트%20트리거⭐.md)** 참고

---

## 4. 자동 vs 수동 업데이트

### 4.1 자동으로 처리되는 경우

`GlanceAppWidgetReceiver`는 시스템 이벤트를 받아 자동으로 `provideGlance()`를 호출합니다:

- ✅ 위젯 추가 (onEnabled)
- ✅ 시스템 업데이트 시간 도래 (onUpdate)
- ✅ 위젯 크기 변경
- ✅ 위젯 삭제 (onDeleted)

> [!NOTE] 💬 발표 설명
> "중요한 점은 **시스템 이벤트는 자동**이지만, **앱 로직에 의한 업데이트는 수동**이라는 겁니다.
>
> 예를 들어 사용자가 위젯 크기를 조절하면 시스템이 자동으로 `provideGlance()`를 호출해서 새 크기에 맞는 UI를 다시 그립니다. 이건 우리가 신경 쓸 필요가 없어요.
>
> 하지만 앱에서 '새로운 데이터를 받았으니 위젯을 갱신해야지'라고 판단하는 건 시스템이 알 수 없습니다. 이럴 때는 명시적으로 `update()`를 호출해야 합니다."

### 4.2 수동 업데이트가 필요한 경우

**앱 로직에 의한 데이터 변경**은 수동으로 업데이트를 호출해야 합니다:

- ✅ WorkManager 작업 완료 후 데이터 갱신
- ✅ 외부 브로드캐스트 수신 (알람, 배터리 상태 변경 등)
- ✅ 앱 내부 데이터베이스 변경
- ✅ 네트워크 API 응답 수신
- ✅ 사용자가 앱에서 설정 변경

```kotlin
// 예: WorkManager에서 데이터 로드 후
class DataSyncWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        // 1. 데이터 로드
        val newData = fetchDataFromServer()

        // 2. 상태 저장
        updateAppWidgetState(context, GlanceId(...)) { prefs ->
            prefs[dataKey] = newData
        }

        // 3. 수동으로 UI 갱신 요청 (필수!)
        MyWidget().updateAll(context)

        return Result.success()
    }
}
```

**자세한 수동 업데이트 방법 및 예제는 → [5. Glance 생명주기 & 업데이트 트리거⭐](5.%20Glance%20생명주기%20&%20업데이트%20트리거⭐.md)** 참고

---

## 5. 전통적인 방식과의 비교

### 4.1 진입점 방식 차이

**전통 위젯 (AppWidgetProvider)**
```kotlin
class TraditionalWidget : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        // 직접 RemoteViews 생성
        appWidgetIds.forEach { appWidgetId ->
            val views = RemoteViews(context.packageName, R.layout.widget_layout)

            // 텍스트 설정
            views.setTextViewText(R.id.widget_text, "Hello Widget")

            // 클릭 이벤트 설정
            val intent = Intent(context, MainActivity::class.java)
            val pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT)
            views.setOnClickPendingIntent(R.id.widget_button, pendingIntent)

            // 업데이트 적용
            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}
```

**Glance 위젯**
```kotlin
class ModernWidgetReceiver : GlanceAppWidgetReceiver() {
    // 단순히 위젯 연결만 지정
    override val glanceAppWidget: GlanceAppWidget = ModernWidget()
}

class ModernWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // Compose 스타일 UI
            Column {
                Text("Hello Widget")
                Button("Click", onClick = actionStartActivity<MainActivity>())
            }
        }
    }
}
```

### 4.2 비교 표

| **구분**      | **전통 위젯**                    | **Glance 위젯**                        |
| ----------- | ---------------------------- | ------------------------------------ |
| **클래스**     | `AppWidgetProvider`          | `GlanceAppWidgetReceiver`            |
| **UI 작성**   | XML + `RemoteViews` 수동 조작    | Compose DSL (자동 `RemoteViews` 변환)    |
| **UI 업데이트** | `updateAppWidget()` 직접 호출    | `update()` / `updateAll()`           |
| **상태 관리**   | `SharedPreferences`/DB 직접 구현 | DataStore 기반 `StateDefinition` 기본 제공 |
| **개발 경험**   | 보일러플레이트 많음                   | 간결, Compose 친화적                      |
| **진입점**     | `onUpdate()` 메서드             | `glanceAppWidget` 프로퍼티               |
| **인스턴스 관리** | `appWidgetIds` 배열로 직접 반복     | `GlanceId` 자동 관리                     |

---

## 6. 주의사항

### 6.1 `super` 호출 필수
모든 생명주기 콜백에서 `super` 메서드를 호출해야 합니다. Glance의 내부 로직이 실행되어야 하기 때문입니다.

```kotlin
// ❌ 잘못된 예
override fun onUpdate(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetIds: IntArray
) {
    // super 호출 없음 → 위젯이 업데이트되지 않음!
}

// ✅ 올바른 예
override fun onUpdate(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetIds: IntArray
) {
    super.onUpdate(context, appWidgetManager, appWidgetIds)
    // 추가 로직...
}
```

### 6.2 매니페스트 등록 확인
`GlanceAppWidgetReceiver`를 상속한 클래스는 반드시 `AndroidManifest.xml`에 등록해야 합니다.

```xml
<receiver
    android:name=".YourWidgetReceiver"
    android:exported="true">  <!-- exported="true" 필수 -->
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/your_widget_info" />
</receiver>
```

### 6.3 `onUpdate()` 직접 구현 지양
일반적으로 `onUpdate()`를 직접 오버라이드할 필요가 없습니다. `GlanceAppWidgetReceiver`가 자동으로 처리합니다.

---

## 7. 체크리스트

- [ ] `GlanceAppWidgetReceiver` 상속한 클래스 작성
- [ ] `glanceAppWidget` 프로퍼티로 위젯 연결
- [ ] `AndroidManifest.xml`에 receiver 등록
- [ ] `exported="true"` 설정 확인
- [ ] 생명주기 콜백에서 `super` 호출 확인
- [ ] `onEnabled`/`onDisabled`에서 전역 리소스 관리 (필요 시)
- [ ] `onDeleted`에서 위젯별 상태 정리 (필요 시)

---
