> [!TIP] 🗣️ 핵심내용
Android의 `AppWidgetProvider`를 확장한 클래스로, 위젯의 진입점 역할을 합니다.
>

## 1. GlanceAppWidgetReceiver 개요

```
📱 시스템 (런처/OS 이벤트)
       │
       ▼
📡 GlanceAppWidgetReceiver
       │  (GlanceAppWidget 연결)
       ▼
🧩 MyGlanceWidget (GlanceAppWidget)
```

> [!NOTE] 💬 발표 설명
> "`GlanceAppWidgetReceiver`는 위젯의 **진입점**입니다. 시스템과 우리가 작성한 위젯 코드를 연결하는 중간 다리 역할을 합니다.
>
> 런처에서 위젯을 추가하거나, 크기를 변경하거나, 업데이트 시간이 되면 시스템이 브로드캐스트를 보냅니다. 이 Receiver가 그걸 받아서 우리가 작성한 `GlanceAppWidget`으로 전달해주는 거죠.
>
> 전통 위젯의 `AppWidgetProvider`의 역할을 GlanceAppWidget이 하는 것 이라고 이해하시면 될 것 같습니다.
### 1.1 핵심 역할
- `AppWidgetProvider`를 대체하는 **Glance 전용 리시버**
- 시스템 브로드캐스트(`APPWIDGET_UPDATE` 등) 수신
- 반드시 매니페스트에 receiver 등록 필요
- `glanceAppWidget` 프로퍼티로 **연결 대상 위젯 지정
- 내부적으로 `GlanceAppWidget.provideGlance()` 실행

---

## 2. 기본 구현

```kotlin
class MyWidgetReceiver : GlanceAppWidgetReceiver() {
    // 필수: 연결할 GlanceAppWidget 지정
    override val glanceAppWidget: GlanceAppWidget = MyWidget()
}
```

```xml
<!-- AndroidManifest.xml -->
<receiver
    android:name=".MyWidgetReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/my_widget_info" />
</receiver>
```

---

## 2.1 AppWidgetProviderInfo 설정

Manifest의 `meta-data`에서 참조하는 위젯 설정 XML 파일입니다. 시스템이 이 파일을 읽어 위젯의 크기, 업데이트 주기, 미리보기 이미지 등을 파악합니다.

### 2.1.1 필수 속성

```xml
<!-- res/xml/my_widget_info.xml -->
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_placeholder"
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen" />
```

| 속성 | 설명 | 필수 여부 |
|------|------|----------|
| `initialLayout` | 위젯 로딩 중 임시로 표시될 플레이스홀더 레이아웃 | ✅ 필수 |
| `minWidth` | 위젯 최소 가로 크기 (dp) | ✅ 필수 |
| `minHeight` | 위젯 최소 세로 크기 (dp) | ✅ 필수 |
| `resizeMode` | 리사이즈 방향 (`horizontal`, `vertical`, `horizontal\|vertical`, `none`) | 권장 |
| `widgetCategory` | 위젯 표시 위치 (`home_screen`, `keyguard`, `searchbox`) | 권장 |

> [!IMPORTANT]
> **`initialLayout`은 절대 필수**입니다. 이 리소스가 없으면 위젯이 위젯 선택 화면에 아예 나타나지 않을 수 있습니다.

---

### 2.1.2 initialLayout 플레이스홀더

위젯 추가 시 Glance가 실제 UI를 렌더링하기 전까지 **몇 밀리초~1초 정도** 임시로 보여줄 레이아웃입니다.

```xml
<!-- res/layout/widget_placeholder.xml -->
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:text="Loading..."
    android:gravity="center"
    android:textColor="#666666"
    android:background="#FFFFFF" />
```

> [!NOTE] 💬 발표 설명
> "`initialLayout`은 **플레이스홀더**입니다. 위젯이 추가되는 순간 시스템이 즉시 보여주는 임시 레이아웃이죠.
>
> Glance가 `provideGlance()`를 실행해서 실제 UI를 만들기 전까지 잠깐 보이는 화면입니다. 'Loading...' 같은 단순한 텍스트나 로고 정도면 충분합니다.
>
> **중요한 점**: 이 리소스 파일이 실제로 존재해야 합니다. 없으면 위젯 선택 화면에 아예 안 뜰 수 있어요. XML 파일 하나 만들고, 간단한 TextView 하나 넣으면 됩니다."

**플레이스홀더 작성 팁**:
- ✅ **반드시 생성**: XML 레이아웃 파일이 실제로 존재해야 함
- ✅ **단순하게**: TextView 하나 정도로 충분
- ✅ **빠른 로딩**: 무거운 레이아웃 피하기
- ⚠️ **미노출 위험**: 없으면 위젯 목록에 안 뜰 수 있음

---

### 2.1.3 크기 관련 속성

```xml
<appwidget-provider
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:minResizeWidth="110dp"
    android:minResizeHeight="40dp"
    android:maxResizeWidth="320dp"
    android:maxResizeHeight="400dp"
    android:targetCellWidth="3"
    android:targetCellHeight="2" />
```

| 속성 | 설명 | 사용 시점 |
|------|------|----------|
| `minResizeWidth` | 사용자가 리사이즈 가능한 최소 가로 크기 | `resizeMode` 포함 시 |
| `minResizeHeight` | 사용자가 리사이즈 가능한 최소 세로 크기 | `resizeMode` 포함 시 |
| `maxResizeWidth` | 리사이즈 가능한 최대 가로 크기 (API 31+) | 최대 크기 제한 필요 시 |
| `maxResizeHeight` | 리사이즈 가능한 최대 세로 크기 (API 31+) | 최대 크기 제한 필요 시 |
| `targetCellWidth` | 권장 가로 셀 수 (API 31+) | 그리드 기반 레이아웃 |
| `targetCellHeight` | 권장 세로 셀 수 (API 31+) | 그리드 기반 레이아웃 |

> [!TIP]
> **SizeMode와의 관계**: XML에서 정의한 크기는 **시스템이 위젯을 배치할 때** 사용하는 힌트입니다. 실제 UI는 `GlanceAppWidget`의 `sizeMode`로 대응합니다.
>
> 자세한 내용: **[8. SizeMode⭐](8.%20SizeMode⭐.md)**

---

### 2.1.4 업데이트 주기

```xml
<appwidget-provider
    android:updatePeriodMillis="1800000" />
```

| 속성 | 설명 | 기본값 |
|------|------|--------|
| `updatePeriodMillis` | 시스템 자동 업데이트 주기 (밀리초) | 0 (업데이트 없음) |

> [!WARNING]
> **제약사항**:
> - 최소값: `1800000` (30분) - 더 짧게 설정해도 시스템이 30분으로 조정
> - 배터리 절약 모드에서는 무시될 수 있음
> - **권장**: WorkManager로 주기적 업데이트 구현 (더 유연함)

---

### 2.1.5 UI 미리보기

```xml
<appwidget-provider
    android:previewImage="@drawable/widget_preview"
    android:previewLayout="@layout/widget_preview_layout"
    android:description="@string/widget_description" />
```

| 속성 | 설명 | API 레벨 |
|------|------|----------|
| `previewImage` | 위젯 선택 화면에 표시될 미리보기 이미지 | API 11+ |
| `previewLayout` | 동적 미리보기 레이아웃 (실제 위젯처럼 표시) | API 31+ |
| `description` | 위젯 설명 (접근성) | API 12+ |

> [!NOTE]
> **description은 반드시 string 리소스**로 정의해야 합니다. 직접 텍스트를 입력하면 빌드 에러가 발생합니다.
> ```xml
> <!-- ❌ 잘못된 예 -->
> android:description="날씨 위젯"
>
> <!-- ✅ 올바른 예 -->
> android:description="@string/weather_widget_description"
> ```

---

### 2.1.6 위젯 카테고리 & 기능

```xml
<appwidget-provider
    android:widgetCategory="home_screen|keyguard"
    android:widgetFeatures="reconfigurable|configuration_optional" />
```

**widgetCategory**:
- `home_screen`: 홈 화면 (기본값)
- `keyguard`: 잠금 화면 (API 17+, Android 5.0부터 deprecated)
- `searchbox`: 검색 위젯 (특수 용도)

**widgetFeatures** (API 21+):
- `reconfigurable`: 위젯 추가 후 재설정 가능
- `configuration_optional`: 설정 화면 선택적 표시

---

### 2.1.7 설정 화면 (선택)

```xml
<appwidget-provider
    android:configure="com.example.MyWidgetConfigActivity" />
```

위젯 추가 시 **설정 화면**을 먼저 보여줍니다. Activity를 지정하면 위젯 추가 전 사용자 설정을 받을 수 있습니다.

---

### 2.1.8 전체 예시

```xml
<!-- res/xml/weather_widget_info.xml -->
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialLayout="@layout/widget_placeholder"
    android:minWidth="180dp"
    android:minHeight="110dp"
    android:minResizeWidth="110dp"
    android:minResizeHeight="40dp"
    android:maxResizeWidth="320dp"
    android:maxResizeHeight="400dp"
    android:resizeMode="horizontal|vertical"
    android:updatePeriodMillis="1800000"
    android:previewImage="@drawable/weather_widget_preview"
    android:previewLayout="@layout/weather_widget_preview_layout"
    android:description="@string/weather_widget_description"
    android:widgetCategory="home_screen"
    android:widgetFeatures="reconfigurable|configuration_optional" />
```

**[스크린샷 추천]** 위젯 선택 화면에서 previewImage가 표시되는 모습

---

## 3. 생명주기 콜백 (선택적 오버라이드)

`GlanceAppWidgetReceiver`는 다음과 같은 생명주기 콜백을 제공합니다:

- **`onEnabled()`**: 첫 번째 위젯 추가 시
- **`onUpdate()`**: 위젯 업데이트 필요 시
- **`onDeleted()`**: 위젯 삭제 시
- **`onDisabled()`**: 마지막 위젯 제거 시

> [!NOTE] 💬 발표 설명
> "생명주기 콜백은 선택적으로 오버라이드할 수 있습니다.
>
> - **onEnabled**: 사용자가 **첫 번째 위젯**을 홈 화면에 추가할 때 딱 한 번 호출됩니다. WorkManager로 주기적 업데이트를 시작하는 용도로 많이 씁니다.
>
> - **onUpdate**: 위젯 업데이트가 필요할 때마다 호출됩니다. 하지만 Glance에서는 이걸 직접 오버라이드할 필요가 거의 없습니다. Glance가 자동으로 처리해주거든요.
>
> - **onDeleted**: 특정 위젯 인스턴스가 삭제될 때 호출됩니다. 해당 인스턴스의 상태 데이터를 정리하는 용도입니다.
>
> - **onDisabled**: **마지막 남은 위젯**이 제거될 때 호출됩니다. 여기서 WorkManager를 중지하거나 전역 리소스를 정리합니다."

**자세한 생명주기 설명과 예제는 → [5. Glance 생명주기 & 업데이트 트리거⭐](5.%20Glance%20생명주기%20&%20업데이트%20트리거⭐.md)** 참고

---

## 4. 자동 vs 수동 업데이트

### 4.1 자동으로 처리되는 경우

`GlanceAppWidgetReceiver`는 시스템 이벤트를 받아 자동으로 `provideGlance()`를 호출합니다:

- ✅ 위젯 추가 (onEnabled)
- ✅ 시스템 업데이트 시간 도래 (onUpdate)
- ✅ 위젯 크기 변경
- ✅ 위젯 삭제 (onDeleted)

> [!NOTE] 💬 발표 설명
> "중요한 점은 **시스템 이벤트는 자동**이지만, **앱 로직에 의한 업데이트는 수동**이라는 겁니다.
>
> 예를 들어 사용자가 위젯 크기를 조절하면 시스템이 자동으로 `provideGlance()`를 호출해서 새 크기에 맞는 UI를 다시 그립니다. 이건 우리가 신경 쓸 필요가 없어요.
>
> 하지만 앱에서 '새로운 데이터를 받았으니 위젯을 갱신해야지'라고 판단하는 건 시스템이 알 수 없습니다. 이럴 때는 명시적으로 `update()`를 호출해야 합니다."

### 4.2 수동 업데이트가 필요한 경우

**앱 로직에 의한 데이터 변경**은 수동으로 업데이트를 호출해야 합니다:

- ✅ WorkManager 작업 완료 후 데이터 갱신
- ✅ 외부 브로드캐스트 수신 (알람, 배터리 상태 변경 등)
- ✅ 앱 내부 데이터베이스 변경
- ✅ 네트워크 API 응답 수신
- ✅ 사용자가 앱에서 설정 변경

```kotlin
// 예: WorkManager에서 데이터 로드 후
class DataSyncWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        // 1. 데이터 로드
        val newData = fetchDataFromServer()

        // 2. 상태 저장
        updateAppWidgetState(context, GlanceId(...)) { prefs ->
            prefs[dataKey] = newData
        }

        // 3. 수동으로 UI 갱신 요청 (필수!)
        MyWidget().updateAll(context)

        return Result.success()
    }
}
```

**자세한 수동 업데이트 방법 및 예제는 → [5. Glance 생명주기 & 업데이트 트리거⭐](5.%20Glance%20생명주기%20&%20업데이트%20트리거⭐.md)** 참고

---

## 5. 전통적인 방식과의 비교

### 4.1 진입점 방식 차이

**전통 위젯 (AppWidgetProvider)**
```kotlin
class TraditionalWidget : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        // 직접 RemoteViews 생성
        appWidgetIds.forEach { appWidgetId ->
            val views = RemoteViews(context.packageName, R.layout.widget_layout)

            // 텍스트 설정
            views.setTextViewText(R.id.widget_text, "Hello Widget")

            // 클릭 이벤트 설정
            val intent = Intent(context, MainActivity::class.java)
            val pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT)
            views.setOnClickPendingIntent(R.id.widget_button, pendingIntent)

            // 업데이트 적용
            appWidgetManager.updateAppWidget(appWidgetId, views)
        }
    }
}
```

**Glance 위젯**
```kotlin
class ModernWidgetReceiver : GlanceAppWidgetReceiver() {
    // 단순히 위젯 연결만 지정
    override val glanceAppWidget: GlanceAppWidget = ModernWidget()
}

class ModernWidget : GlanceAppWidget() {
    override suspend fun provideGlance(context: Context, id: GlanceId) {
        provideContent {
            // Compose 스타일 UI
            Column {
                Text("Hello Widget")
                Button("Click", onClick = actionStartActivity<MainActivity>())
            }
        }
    }
}
```

### 4.2 비교 표

| **구분**      | **전통 위젯**                    | **Glance 위젯**                        |
| ----------- | ---------------------------- | ------------------------------------ |
| **클래스**     | `AppWidgetProvider`          | `GlanceAppWidgetReceiver`            |
| **UI 작성**   | XML + `RemoteViews` 수동 조작    | Compose DSL (자동 `RemoteViews` 변환)    |
| **UI 업데이트** | `updateAppWidget()` 직접 호출    | `update()` / `updateAll()`           |
| **상태 관리**   | `SharedPreferences`/DB 직접 구현 | DataStore 기반 `StateDefinition` 기본 제공 |
| **개발 경험**   | 보일러플레이트 많음                   | 간결, Compose 친화적                      |
| **진입점**     | `onUpdate()` 메서드             | `glanceAppWidget` 프로퍼티               |
| **인스턴스 관리** | `appWidgetIds` 배열로 직접 반복     | `GlanceId` 자동 관리                     |

---

## 6. 주의사항

### 6.1 `super` 호출 필수
모든 생명주기 콜백에서 `super` 메서드를 호출해야 합니다. Glance의 내부 로직이 실행되어야 하기 때문입니다.

```kotlin
// ❌ 잘못된 예
override fun onUpdate(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetIds: IntArray
) {
    // super 호출 없음 → 위젯이 업데이트되지 않음!
}

// ✅ 올바른 예
override fun onUpdate(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetIds: IntArray
) {
     // 추가 로직...
    super.onUpdate(context, appWidgetManager, appWidgetIds)
}
```

### 6.2 `onUpdate()` 직접 구현 지양
일반적으로 `onUpdate()`를 직접 오버라이드할 필요가 없습니다. `GlanceAppWidgetReceiver`가 자동으로 처리합니다.

---